import { TAnyFunction } from './interface';
export declare class Serializer {
    private _constructorList;
    private _classes;
    private static _getUniqFunctionName;
    serialize(data: any): ISerialized;
    private _addConstructor;
    private _clear;
    static isNative(data: (...args: Array<any>) => any): boolean;
    static isInstance(some: any): boolean;
    static getClassParents(Factory: TAnyFunction): Array<TAnyFunction>;
    static isFunction(Factory: TAnyFunction): boolean;
    static functionToString(func: (...args: Array<any>) => any): string;
    static getFullClassTemplate(Factory: TAnyFunction): Array<{
        name: string;
        template: string;
        factory: TAnyFunction;
    }>;
    static getFnName(fn: TAnyFunction): string | null;
    static getFnNameForce(func: TAnyFunction): string;
    private static _getClassData;
    private static _getClassTemplate;
    private static _getConstructorTemplate;
    private static _getPrototypeTemplate;
    private static _getStaticTemplate;
    private static _getPrototypeItemTemplate;
    private static _getStaticItemTemplate;
    private static _replaceSuper;
    private static _getSuperReg;
}
export interface ISerialized {
    data: any;
    classes: Array<IClassData>;
}
export interface IClassData {
    name: string;
    template: string;
    parent?: number;
}
export interface IFunctionDataItem {
    __type: 'serialized-function';
    template: string;
}
export interface IClassDataItem {
    __type: 'serialized-class';
    index: number;
}
export interface IInstanceDataItem {
    __type: 'serialized-instance';
    index: number;
    data: any;
}
export interface INativeInstanceItem {
    __type: 'serialized-native-instance';
    constructorName: string;
    data: any;
}
export declare type TSerializedDataITem = IFunctionDataItem | IClassDataItem | IInstanceDataItem | INativeInstanceItem;
