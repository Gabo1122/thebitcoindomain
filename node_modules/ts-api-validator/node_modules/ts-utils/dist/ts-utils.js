(function (f) {
    var dependency = [];
    var main = "index";
    var name = "ts-utils";
    if (typeof exports === 'object' && typeof module !== 'undefined') {
        module.exports = f(0 /* NODE */, main, dependency);
    }
    else if (typeof define === 'function' && define.amd) {
        if (name) {
            define(name, dependency, f.bind(null, 1 /* AMD */, main, dependency));
        }
        else {
            define(dependency, f.bind(null, 1 /* AMD */, main, dependency));
        }
    }
    else {
        var g = void 0;
        if (typeof window !== 'undefined') {
            g = window;
        }
        else if (typeof global !== 'undefined') {
            g = global;
        }
        else if (typeof self !== 'undefined') {
            g = self;
        }
        else {
            g = this;
        }
        f.call(g, 2 /* NONE */, main, dependency);
    }
})(function (type, main, dependencyString, dependency) {
    var body = function (define) {
        var __assign = (this && this.__assign) || Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
        s = arguments[i];
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
            t[p] = s[p];
    }
    return t;
};
(function () {define("src/Iterator", ["require", "exports"], function (require, exports) {
    "use strict";
    exports.__esModule = true;
    var Iterator = /** @class */ (function () {
        function Iterator(some) {
            this._step = 0;
            this._list = some;
        }
        Iterator.prototype.next = function () {
            if (this._step < this._list.length) {
                var result = {
                    done: false,
                    value: this._list[this._step]
                };
                this._step++;
                return result;
            }
            else {
                return {
                    done: true
                };
            }
        };
        return Iterator;
    }());
    exports.Iterator = Iterator;
});})();
(function () {define("src/Path", ["require", "exports", "src/Iterator"], function (require, exports, Iterator_1) {
    "use strict";
    exports.__esModule = true;
    var Path = /** @class */ (function () {
        function Path(path) {
            this._path = path;
            this.length = this._path.length;
        }
        Path.prototype.reverse = function () {
            return new Path(this._path.slice().reverse());
        };
        Path.prototype.iterator = function () {
            var _this = this;
            return new Iterator_1.Iterator(this._path.map(function (item, index) { return _this.getItemData(index); }));
        };
        Path.prototype.slice = function (start, end) {
            return new Path(this._path.slice(start, end));
        };
        Path.prototype.forEach = function (cb, context) {
            var _this = this;
            return this._path.forEach(function (item, index) {
                cb.call(context, _this.getItemData(index), index);
            });
        };
        Path.prototype.some = function (cb, context) {
            var _this = this;
            return this._path.some(function (item, index) {
                return cb.call(context, _this.getItemData(index), index);
            });
        };
        Path.prototype.toString = function () {
            return this._path.map(function (item, i) {
                switch (item.type) {
                    case 0 /* Object */:
                        return i === 0 ? item.name : "." + item.name;
                    case 1 /* Array */:
                        return "[" + item.name + "]";
                }
            }).join('');
        };
        Path.prototype.getItemData = function (index) {
            var container = Path.getContainer(this._path[index].type);
            var nextContainer = this._path[index + 1] && Path.getContainer(this._path[index + 1].type) || null;
            return { name: this._path[index].name, container: container, nextContainer: nextContainer };
        };
        Path.parse = function (path) {
            var parts = [];
            path.split('.').forEach(function (key) {
                if (key === '') {
                    parts.push({
                        type: 0 /* Object */,
                        key: key
                    });
                }
                else {
                    var _a = key.replace(/\[(.*)?\]/, '|$1').split('|'), name_1 = _a[0], index = _a[1];
                    if (name_1) {
                        var num = Number(name_1);
                        if (String(num) === name_1) {
                            parts.push({
                                type: 1 /* Array */,
                                name: name_1
                            });
                        }
                        else {
                            parts.push({
                                type: 0 /* Object */,
                                name: name_1
                            });
                        }
                    }
                    if (index) {
                        parts.push({
                            type: 1 /* Array */,
                            name: index
                        });
                    }
                }
            });
            return new Path(parts);
        };
        Path.getContainer = function (type) {
            switch (type) {
                case 0 /* Object */:
                    return Object.create(null);
                case 1 /* Array */:
                    return [];
            }
        };
        return Path;
    }());
    exports.Path = Path;
});})();
(function () {define("src/utils", ["require", "exports", "src/Path"], function (require, exports, Path_1) {
    "use strict";
    exports.__esModule = true;
    /**
     * @private
     * @type {{string: string; number: string; object: string; array: string}}
     */
    var TYPES = {
        string: '[object String]',
        number: '[object Number]',
        boolean: '[object Boolean]',
        object: '[object Object]',
        array: '[object Array]'
    };
    /**
     * @private
     * @type {() => string}
     */
    var toString = Object.prototype.toString;
    exports.DEFAULT_NUMBER_SEPARATOR = '.';
    /**
     * Check the parameter type
     * Is the parameter an object
     * @param param
     * @returns {boolean}
     */
    function isObject(param) {
        return toString.call(param) === TYPES.object;
    }
    exports.isObject = isObject;
    /**
     * Check the parameter
     * Whether the parameter is null or undefined
     * @param param
     * @returns {boolean}
     */
    function isEmpty(param) {
        return param == null;
    }
    exports.isEmpty = isEmpty;
    /**
     * Check the parameter
     * Whether the parameter is not null or is not undefined
     * @param param
     * @returns {boolean}
     */
    function isNotEmpty(param) {
        return param != null;
    }
    exports.isNotEmpty = isNotEmpty;
    /**
     * Check the parameter type
     * Is the parameter an string
     * @param param
     * @returns {boolean}
     */
    function isString(param) {
        return toString.call(param) === TYPES.string;
    }
    exports.isString = isString;
    /**
     * Check the parameter type
     * Is the parameter an number
     * @param param
     * @returns {boolean}
     */
    function isNumber(param) {
        return toString.call(param) === TYPES.number;
    }
    exports.isNumber = isNumber;
    /**
     * Check the parameter type
     * Is the parameter an array
     * @param param
     * @returns {boolean}
     */
    function isArray(param) {
        return toString.call(param) === TYPES.array;
    }
    exports.isArray = isArray;
    /**
     * Check the parameter type
     * Is the parameter an boolean
     * @param param
     * @returns {boolean}
     */
    function isBoolean(param) {
        return toString.call(param) === TYPES.boolean;
    }
    exports.isBoolean = isBoolean;
    /**
     * Check the parameter type
     * Is the parameter an null
     * @param param
     * @returns {boolean}
     */
    function isNull(param) {
        return param === null;
    }
    exports.isNull = isNull;
    /**
     * Check the parameter type
     * Is the parameter an undefined
     * @param param
     * @returns {boolean}
     */
    function isUndefined(param) {
        return param === undefined;
    }
    exports.isUndefined = isUndefined;
    /**
     * Check the parameter type
     * Is the parameter an NaN
     * @param param
     * @returns {boolean}
     */
    function isNaNCheck(param) {
        return isNumber(param) && isNaN(param);
    }
    exports.isNaNCheck = isNaNCheck;
    /**
     * Check the parameter type
     * Is the parameter an function
     * @param param
     * @returns {boolean}
     */
    function isFunction(param) {
        return typeof param === 'function';
    }
    exports.isFunction = isFunction;
    /**
     *
     * @param param
     * @returns {TTypes}
     */
    function typeOf(param) {
        var type = typeof param;
        switch (type) {
            case 'object':
                if (param === null) {
                    return 'null';
                }
                else {
                    var checkList = [
                        { check: isArray, type: 'array' },
                        { check: isObject, type: 'object' },
                        { check: isString, type: 'string' },
                        { check: isNumber, type: 'number' },
                        { check: isBoolean, type: 'boolean' }
                    ];
                    var $type_1 = 'null';
                    checkList.some(function (item) {
                        if (item.check(param)) {
                            $type_1 = item.type;
                        }
                        return $type_1 !== 'null';
                    });
                    return $type_1;
                }
            default:
                return type;
        }
    }
    exports.typeOf = typeOf;
    /**
     * Give the number to a certain number of symbols
     *
     * @example
     * numToLength(22, 3) // returns '022'
     * @example
     * numToLength(new Date().getHours(), 2) //returns '06'
     *
     * @param {number} num
     * @param {number} length
     * @returns {string}
     */
    function numToLength(num, length) {
        var str = String(num);
        for (var i = str.length; i < length; i++) {
            str = '0' + str;
        }
        return str;
    }
    exports.numToLength = numToLength;
    /**
     * Safely rounds a number to a character
     * @param {number} num
     * @param {number} len
     * @returns {number}
     */
    function round(num, len) {
        len = len || 2;
        return Number(Math.round(Number(num + 'e' + len)) + 'e-' + len);
    }
    exports.round = round;
    /**
     * Format a number
     *
     * @example
     * splitRange(21257.32, {separator: ','}) // returns '21 257,32'
     *
     * @example
     * splitRange(21257.322, {separator: ','}, (num) => round(num, 2)) // returns '21 257,32'
     *
     * @param {number} num
     * @param {ISplitRangeOptions} options format options
     * @param {IFilter<number, number>} processor function for preprocess param
     * @returns {string}
     */
    function splitRange(num, options, processor) {
        if (processor) {
            num = processor(num);
        }
        var str = String(num);
        var numData = str.split('.');
        var integral = numData[0], fractional = numData[1];
        integral = integral.split('').reverse().join('');
        integral = integral.replace(/(\d{3})/g, '$1 ')
            .split('').reverse().join('').replace(/\s/g, options && options.nbsp ? '&nbsp;' : ' ').trim();
        if (fractional) {
            return integral + (options && options.separator || exports.DEFAULT_NUMBER_SEPARATOR) + fractional;
        }
        return integral;
    }
    exports.splitRange = splitRange;
    /**
     * A generic iterator function, which can be used to seamlessly iterate over objects.
     * Like forEach for array
     * @param {Array<T> | IHash<T>} param
     * @param {(data: T, key: (string | number))} callback
     * @param context
     */
    function each(param, callback, context) {
        if (typeof param !== 'object' || !param) {
            return null;
        }
        if (context) {
            return Array.isArray(param) ? param.forEach(callback, context) :
                Object.keys(param).forEach(function (key) { return callback.call(context, param[key], key); });
        }
        else {
            return Array.isArray(param) ? param.forEach(callback) :
                Object.keys(param).forEach(function (key) { return callback(param[key], key); });
        }
    }
    exports.each = each;
    /**
     * The general iterator function that can be used to test a particular property.
     * Like some for array
     * @param {Object} param
     * @param {ISomeCallback<T>} callback
     * @returns {boolean}
     */
    function some(param, callback) {
        return Object.keys(param).some(function (key) { return callback(param[key], key); });
    }
    exports.some = some;
    /**
     * Get some data from object by string path
     *
     * @example
     * get({a: {b: 1}}), 'a.b') // returns 1
     *
     * @param {Object} data
     * @param {string} path
     * @returns {T}
     */
    function get(data, path) {
        var tmp = data;
        var parts = isString(path) ? Path_1.Path.parse(path) : path;
        parts.some(function (item) {
            if (typeof tmp === 'object' && tmp !== null && (item.name in tmp)) {
                tmp = tmp[item.name];
            }
            else {
                tmp = null;
                return true;
            }
        });
        return tmp;
    }
    exports.get = get;
    /**
     * Set some data to object by string path
     *
     * @example
     * var some = {};
     * set(some), 'a.b', 1) // some equal {a: {b: 1}}
     *
     * @param {Object} data
     * @param {string} path
     * @param value
     */
    function set(data, path, value) {
        var tmp = data;
        var parts = isString(path) ? Path_1.Path.parse(path) : path;
        parts.forEach(function (itemData, index) {
            var isLast = index === parts.length - 1;
            if (isLast) {
                tmp[itemData.name] = value;
            }
            else {
                if (typeof tmp[itemData.name] !== 'object') {
                    tmp[itemData.name] = itemData.nextContainer;
                }
                tmp = tmp[itemData.name];
            }
        });
    }
    exports.set = set;
    function getLayers(data, path) {
        var tmp = data;
        var layers = [{ name: null, data: data, parent: null }];
        var parts = isString(path) ? Path_1.Path.parse(path) : path;
        parts.forEach(function (item) {
            if (tmp) {
                layers.push({ name: item.name, data: tmp[item.name], parent: tmp });
                tmp = tmp[item.name];
            }
            else {
                layers = null;
            }
        });
        return layers;
    }
    exports.getLayers = getLayers;
    function unset(data, path) {
        (getLayers(data, path) || []).reverse().some(function (item, index) {
            if (index === 0) {
                if (item.parent) {
                    delete item.parent[item.name];
                }
            }
            else {
                if (item.parent && Object.keys(item.data).length === 0) {
                    delete item.parent[item.name];
                }
            }
        });
    }
    exports.unset = unset;
    var counter = 0;
    function uniqueId(prefix) {
        if (prefix === void 0) { prefix = ''; }
        return "" + prefix + counter++;
    }
    exports.uniqueId = uniqueId;
    function result(param) {
        if (isFunction(param)) {
            return param();
        }
        else {
            return param;
        }
    }
    exports.result = result;
    /**
     * Get array all path from object
     *
     * @example
     * getPaths({a: {b: 1, c: 2}, d: 1}) // return [['a', 'b'], ['a', 'c'], ['d']]
     *
     * @param {Object} param
     * @returns {Array<Array<string>>}
     */
    function getPaths(param) {
        var paths = [];
        function getIterate(parents, array) {
            var iterate = function (value, key) {
                var newLine = parents.slice();
                newLine.push({ type: array ? 1 /* Array */ : 0 /* Object */, name: key });
                if (isObject(value)) {
                    each(value, getIterate(newLine));
                }
                else if (isArray(value)) {
                    each(value, getIterate(newLine, true));
                }
                else {
                    paths.push(newLine);
                }
            };
            return iterate;
        }
        var firstLine = [];
        each(param, getIterate(firstLine, isArray(param)));
        return paths.map(function (pathParts) { return new Path_1.Path(pathParts); });
    }
    exports.getPaths = getPaths;
    function clone(data) {
        switch (typeof data) {
            case 'object':
                if (data === null) {
                    return null;
                }
                if (Array.isArray(data)) {
                    return data.slice();
                }
                else {
                    return __assign({}, data);
                }
            default:
                return data;
        }
    }
    exports.clone = clone;
    function cloneDeep(data) {
        switch (typeof data) {
            case 'object':
                var paths = getPaths(data);
                var $clone_1 = isArray(data) ? [] : Object.create(null);
                paths.forEach(function (path) {
                    var value = get(data, path);
                    set($clone_1, path, value);
                });
                return $clone_1;
            default:
                return data;
        }
    }
    exports.cloneDeep = cloneDeep;
    function merge(origin) {
        var args = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            args[_i - 1] = arguments[_i];
        }
        args.forEach(function (part) {
            var paths = getPaths(part);
            paths.forEach(function (path) {
                var value = get(part, path);
                set(origin, path, value);
            });
        });
        return origin;
    }
    exports.merge = merge;
    function defaults(target) {
        var args = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            args[_i - 1] = arguments[_i];
        }
        var paths = getPaths(target).map(String);
        args.reverse().forEach(function (item) {
            var itemPaths = getPaths(item);
            itemPaths.forEach(function (path) {
                var stringPath = path.toString();
                if (paths.indexOf(stringPath) === -1) {
                    paths.push(stringPath);
                    set(target, path, get(item, path));
                }
            });
        });
        return target;
    }
    exports.defaults = defaults;
});})();
(function () {define("src/filters", ["require", "exports", "src/utils"], function (require, exports, utils_1) {
    "use strict";
    exports.__esModule = true;
    var EMPTY_FUNCS_MAP = {
        skipNumber: utils_1.isNumber,
        skipString: utils_1.isString,
        skipNotEmpty: utils_1.isNotEmpty,
        skipNull: utils_1.isNull,
        skipUndefined: utils_1.isUndefined
    };
    function not(processor) {
        if (processor) {
            return function (data) { return !processor(data); };
        }
        else {
            return function (data) { return !data; };
        }
    }
    exports.not = not;
    function empty(options) {
        if (!options) {
            return Boolean;
        }
        var functions = [];
        utils_1.each(options, function (value, optionName) {
            if (EMPTY_FUNCS_MAP[optionName] && value) {
                functions.push(EMPTY_FUNCS_MAP[optionName]);
            }
        });
        if (!functions.length) {
            return Boolean;
        }
        else {
            return function (data) {
                return functions.some(function (f) { return f(data); }) || !!data;
            };
        }
    }
    exports.empty = empty;
    function contains(data) {
        if (typeof data === 'object') {
            var keys_1 = Object.keys(data);
            return function (localData) {
                if (!utils_1.isObject(localData)) {
                    return false;
                }
                return keys_1.every(function (key) { return data[key] === localData[key]; });
            };
        }
        else {
            return function (localData) {
                return data === localData;
            };
        }
    }
    exports.contains = contains;
    function containsDeep(data) {
        var paths = utils_1.getPaths(data);
        var check = function (localData) {
            return paths.every(function (parts) {
                return utils_1.get(data, parts) === utils_1.get(localData, parts);
            });
        };
        return function (localData) {
            if (typeof localData === 'object') {
                return check(localData);
            }
            else {
                return false;
            }
        };
    }
    exports.containsDeep = containsDeep;
    function notContains(data) {
        return not(contains(data));
    }
    exports.notContains = notContains;
    function notContainsDeep(data) {
        return not(containsDeep(data));
    }
    exports.notContainsDeep = notContainsDeep;
    function roundFilter(len) {
        return function (num) { return utils_1.round(num, len); };
    }
    exports.roundFilter = roundFilter;
    function splitRangeFilter(data, processor) {
        return function (num) { return utils_1.splitRange(num, data, processor); };
    }
    exports.splitRangeFilter = splitRangeFilter;
    function roundSplit(len, data) {
        return splitRangeFilter(data, roundFilter(len));
    }
    exports.roundSplit = roundSplit;
    function equal(some, noStrict) {
        if (noStrict) {
            return function (data) {
                /* tslint:disable */
                return some == data;
                /* tslint:enable */
            };
        }
        return function (data) {
            return some === data;
        };
    }
    exports.equal = equal;
    function notEqual(some, noStrict) {
        return not(equal(some, noStrict));
    }
    exports.notEqual = notEqual;
    var dateParsers = [
        {
            pattern: 'YYYY',
            handler: function (localDate) { return String(localDate.getFullYear()); }
        },
        {
            pattern: 'YY',
            handler: function (localDate) { return String(localDate.getFullYear()).substr(2); }
        },
        {
            pattern: 'MM',
            handler: function (localDate) { return String(utils_1.numToLength(localDate.getMonth() + 1, 2)); }
        },
        {
            pattern: 'M',
            handler: function (localDate) { return String(localDate.getMonth() + 1); }
        },
        {
            pattern: 'DD',
            handler: function (localDate) { return String(utils_1.numToLength(localDate.getDate(), 2)); }
        },
        {
            pattern: 'D',
            handler: function (localDate) { return String(localDate.getDate()); }
        },
        {
            pattern: 'hh',
            handler: function (localDate) { return String(utils_1.numToLength(localDate.getHours(), 2)); }
        },
        {
            pattern: 'h',
            handler: function (localDate) { return String(localDate.getHours()); }
        },
        {
            pattern: 'mm',
            handler: function (localDate) { return String(utils_1.numToLength(localDate.getMinutes(), 2)); }
        },
        {
            pattern: 'm',
            handler: function (localDate) { return String(localDate.getMinutes()); }
        },
        {
            pattern: 'ss',
            handler: function (localDate) { return String(utils_1.numToLength(localDate.getSeconds(), 2)); }
        },
        {
            pattern: 's',
            handler: function (localDate) { return String(localDate.getSeconds()); }
        }
    ];
    function date(pattern, processor) {
        var localPatterns = [];
        var forFind = pattern;
        var parse;
        dateParsers.forEach(function (datePattern) {
            if (forFind.indexOf(datePattern.pattern) !== -1) {
                forFind = forFind.replace(datePattern.pattern, '');
                localPatterns.push(datePattern);
            }
        });
        if (processor) {
            parse = function (toParse) {
                var result = processor(toParse);
                return utils_1.isNumber(result) ? new Date(result) : result;
            };
        }
        else {
            parse = function (data) {
                return utils_1.isNumber(data) ? new Date(data) : data;
            };
        }
        return function (localDate) {
            var _date = parse(localDate);
            return localPatterns.reduce(function (result, datePattern) {
                return result.replace(datePattern.pattern, datePattern.handler(_date));
            }, pattern);
        };
    }
    exports.date = date;
    function getBinaryFilter(data) {
        var dataPaths = utils_1.getPaths(data);
        if (dataPaths.length === 1) {
            var path_1 = dataPaths[0];
            var value_1 = utils_1.get(data, path_1);
            return function (item) {
                var itemValue = utils_1.get(item, path_1);
                return itemValue > value_1 ? -1 : itemValue === value_1 ? 0 : 1;
            };
        }
        else {
            var pathsStr_1 = dataPaths.map(String);
            var pathsHash_1 = Object.create(null);
            dataPaths.forEach(function (path) {
                pathsHash_1[String(path)] = utils_1.get(data, path);
            });
            return function (item) {
                var map = dataPaths.map(function (path, i) {
                    var itemValue = utils_1.get(item, path);
                    var pathStr = pathsStr_1[i];
                    return itemValue > pathsHash_1[pathStr] ? -1 : itemValue === pathsHash_1[pathStr] ? 0 : 1;
                });
                var witoutZero = map.filter(Boolean);
                if (witoutZero.length === 0) {
                    return 0;
                }
                else {
                    return witoutZero[0];
                }
            };
        }
    }
    exports.getBinaryFilter = getBinaryFilter;
});})();
(function () {define("src/Receiver", ["require", "exports"], function (require, exports) {
    "use strict";
    exports.__esModule = true;
    var Receiver = /** @class */ (function () {
        function Receiver() {
        }
        Receiver.prototype.receive = function (signal, handler, context) {
            receive.call(this, signal, handler, context, false);
        };
        Receiver.prototype.receiveOnce = function (signal, handler, context) {
            receive.call(this, signal, handler, context, true);
        };
        Receiver.prototype.stopReceive = function (item, handler) {
            var _this = this;
            if (!this.__received) {
                return null;
            }
            if (typeof item === 'function') {
                handler = item;
                item = null;
            }
            if (!item) {
                Object.keys(this.__received).forEach(function (cid) {
                    _this.stopReceive(_this.__received[cid].signal, handler);
                });
                return null;
            }
            if (!handler) {
                this.__received[item.cid].handlers.forEach(function (myHandler) {
                    _this.stopReceive(item, myHandler);
                });
                return null;
            }
            var handlers = this.__received[item.cid].handlers;
            for (var i = handlers.length; i--;) {
                if (handlers[i] === handler) {
                    handlers.splice(i, 1);
                    this.__received[item.cid].signal.off(handler);
                }
            }
            if (!handlers.length) {
                delete this.__received[item.cid];
            }
        };
        return Receiver;
    }());
    exports.Receiver = Receiver;
    function receive(signal, handler, context, isOnce) {
        if (!this.__received) {
            this.__received = Object.create(null);
        }
        if (isOnce) {
            signal.once(handler, context, this);
        }
        else {
            signal.on(handler, context, this);
        }
        if (!this.__received[signal.cid]) {
            this.__received[signal.cid] = {
                handlers: [handler],
                signal: signal
            };
        }
        else {
            this.__received[signal.cid].handlers.push(handler);
        }
    }
});})();
(function () {define("src/Signal", ["require", "exports", "src/utils"], function (require, exports, utils_2) {
    "use strict";
    exports.__esModule = true;
    var Signal = /** @class */ (function () {
        function Signal() {
            this.cid = utils_2.uniqueId('signal');
            this._handlers = [];
        }
        Signal.prototype.on = function (handler, context, receiver) {
            this._handlers.push({
                isOnce: false,
                handler: handler,
                context: context,
                receiver: receiver
            });
        };
        Signal.prototype.once = function (handler, context, receiver) {
            this._handlers.push({
                isOnce: true,
                handler: handler,
                context: context,
                receiver: receiver
            });
        };
        Signal.prototype.off = function (handler) {
            var _this = this;
            if (handler) {
                for (var i = this._handlers.length; i--;) {
                    var handlerData = this._handlers[i];
                    if (handlerData.handler === handler) {
                        this._handlers.splice(i, 1);
                        if (handlerData.receiver) {
                            handlerData.receiver.stopReceive(this, handler);
                        }
                    }
                }
            }
            else {
                var handlers = this._handlers.slice();
                this._handlers = [];
                handlers.forEach(function (data) {
                    if (data.receiver) {
                        data.receiver.stopReceive(_this, data.handler);
                    }
                });
            }
        };
        Signal.prototype.dispatch = function (some) {
            var _this = this;
            this._handlers.slice().forEach(function (handlerData) {
                if (handlerData.isOnce) {
                    _this.off(handlerData.handler);
                }
                handlerData.handler.call(handlerData.context, some);
            });
        };
        return Signal;
    }());
    exports.Signal = Signal;
});})();
(function () {define("src/utilsWithFilters", ["require", "exports", "src/utils", "src/filters"], function (require, exports, utils_3, filters_1) {
    "use strict";
    exports.__esModule = true;
    function find(some, target) {
        var filter = utils_3.isFunction(target) ? target : filters_1.contains(target);
        var result = null;
        if (utils_3.isArray(some)) {
            some.some(function (data) {
                if (filter(data)) {
                    result = data;
                    return true;
                }
            });
        }
        else {
            Object.keys(some).some(function (key) {
                if (filter(some[key])) {
                    result = some[key];
                    return true;
                }
            });
        }
        return result;
    }
    exports.find = find;
    function binaryFind(some, target) {
        var result = {
            index: -1,
            value: null
        };
        var delta = 0;
        var step = function (arr) {
            var index = Math.floor(arr.length / 2);
            var item = arr[index];
            switch (target(item)) {
                case -1:
                    step(arr.slice(0, index));
                    break;
                case 0:
                    result = { index: index + delta, value: item };
                    break;
                case 1:
                    delta += index;
                    step(arr.slice(index));
                    break;
            }
        };
        step(some.slice());
        return result;
    }
    exports.binaryFind = binaryFind;
});})();
(function () {define("index", ["require", "exports", "src/utils", "src/filters", "src/Signal", "src/utilsWithFilters", "src/Path", "src/Iterator", "src/Receiver"], function (require, exports, utils_4, filters_2, Signal_1, utilsWithFilters_1, Path_2, Iterator_2, Receiver_1) {
    "use strict";
    function __export(m) {
        for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
    }
    exports.__esModule = true;
    __export(utils_4);
    __export(filters_2);
    __export(Signal_1);
    __export(utilsWithFilters_1);
    __export(Path_2);
    __export(Iterator_2);
    __export(Receiver_1);
});})();
;
    };
    var global = this;
    var camelCase = function (str) {
        return str.split(/\W|_/)
            .map(function (part, i) { return (i === 0 ? part : part.charAt(0).toUpperCase() + part.substr(1)); })
            .join('');
    };
    var exports = Object.create(null);
    var myRequire;
    switch (type) {
        case 0 /* NODE */:
            myRequire = function (name) {
                if (dependencyString.indexOf(name) !== -1) {
                    return require(name);
                }
                else {
                    if (name in exports) {
                        return exports[name];
                    }
                    throw new Error("Can't find module \"" + name + "\"");
                }
            };
            break;
        default:
            myRequire = function (name) {
                var index = dependencyString.indexOf(name);
                if (index === -1) {
                    if (name in exports) {
                        return exports[name];
                    }
                    throw new Error("Can't find module \"" + name + "\"");
                }
                else {
                    return dependency && dependency[index] || global[name] || global[camelCase(name)];
                }
            };
    }
    var define = function (moduleName, moduleDependency, callback) {
        exports[moduleName] = {};
        var args = moduleDependency.map(function (dependencyName) {
            switch (dependencyName) {
                case 'require':
                    return myRequire;
                case 'exports':
                    return exports[moduleName];
                default:
                    return myRequire(dependencyName);
            }
        });
        var result = callback.apply(global, args);
        if (result != null && Object.keys(exports[moduleName]).length === 0) {
            exports[moduleName] = result;
        }
    };
    body(define);
    if ("ts-utils" && type === 2 /* NONE */) {
        global[camelCase("ts-utils")] = exports[main];
    }
    return exports[main];
});
