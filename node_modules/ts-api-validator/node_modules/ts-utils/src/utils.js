"use strict";
var __assign = (this && this.__assign) || Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
        s = arguments[i];
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
            t[p] = s[p];
    }
    return t;
};
Object.defineProperty(exports, "__esModule", { value: true });
var Path_1 = require("./Path");
/**
 * @private
 * @type {{string: string; number: string; object: string; array: string}}
 */
var TYPES = {
    string: '[object String]',
    number: '[object Number]',
    boolean: '[object Boolean]',
    object: '[object Object]',
    array: '[object Array]'
};
/**
 * @private
 * @type {() => string}
 */
var toString = Object.prototype.toString;
exports.DEFAULT_NUMBER_SEPARATOR = '.';
/**
 * Check the parameter type
 * Is the parameter an object
 * @param param
 * @returns {boolean}
 */
function isObject(param) {
    return toString.call(param) === TYPES.object;
}
exports.isObject = isObject;
/**
 * Check the parameter
 * Whether the parameter is null or undefined
 * @param param
 * @returns {boolean}
 */
function isEmpty(param) {
    return param == null;
}
exports.isEmpty = isEmpty;
/**
 * Check the parameter
 * Whether the parameter is not null or is not undefined
 * @param param
 * @returns {boolean}
 */
function isNotEmpty(param) {
    return param != null;
}
exports.isNotEmpty = isNotEmpty;
/**
 * Check the parameter type
 * Is the parameter an string
 * @param param
 * @returns {boolean}
 */
function isString(param) {
    return toString.call(param) === TYPES.string;
}
exports.isString = isString;
/**
 * Check the parameter type
 * Is the parameter an number
 * @param param
 * @returns {boolean}
 */
function isNumber(param) {
    return toString.call(param) === TYPES.number;
}
exports.isNumber = isNumber;
/**
 * Check the parameter type
 * Is the parameter an array
 * @param param
 * @returns {boolean}
 */
function isArray(param) {
    return toString.call(param) === TYPES.array;
}
exports.isArray = isArray;
/**
 * Check the parameter type
 * Is the parameter an boolean
 * @param param
 * @returns {boolean}
 */
function isBoolean(param) {
    return toString.call(param) === TYPES.boolean;
}
exports.isBoolean = isBoolean;
/**
 * Check the parameter type
 * Is the parameter an null
 * @param param
 * @returns {boolean}
 */
function isNull(param) {
    return param === null;
}
exports.isNull = isNull;
/**
 * Check the parameter type
 * Is the parameter an undefined
 * @param param
 * @returns {boolean}
 */
function isUndefined(param) {
    return param === undefined;
}
exports.isUndefined = isUndefined;
/**
 * Check the parameter type
 * Is the parameter an NaN
 * @param param
 * @returns {boolean}
 */
function isNaNCheck(param) {
    return isNumber(param) && isNaN(param);
}
exports.isNaNCheck = isNaNCheck;
/**
 * Check the parameter type
 * Is the parameter an function
 * @param param
 * @returns {boolean}
 */
function isFunction(param) {
    return typeof param === 'function';
}
exports.isFunction = isFunction;
/**
 *
 * @param param
 * @returns {TTypes}
 */
function typeOf(param) {
    var type = typeof param;
    switch (type) {
        case 'object':
            if (param === null) {
                return 'null';
            }
            else {
                var checkList = [
                    { check: isArray, type: 'array' },
                    { check: isObject, type: 'object' },
                    { check: isString, type: 'string' },
                    { check: isNumber, type: 'number' },
                    { check: isBoolean, type: 'boolean' }
                ];
                var $type_1 = 'null';
                checkList.some(function (item) {
                    if (item.check(param)) {
                        $type_1 = item.type;
                    }
                    return $type_1 !== 'null';
                });
                return $type_1;
            }
        default:
            return type;
    }
}
exports.typeOf = typeOf;
/**
 * Give the number to a certain number of symbols
 *
 * @example
 * numToLength(22, 3) // returns '022'
 * @example
 * numToLength(new Date().getHours(), 2) //returns '06'
 *
 * @param {number} num
 * @param {number} length
 * @returns {string}
 */
function numToLength(num, length) {
    var str = String(num);
    for (var i = str.length; i < length; i++) {
        str = '0' + str;
    }
    return str;
}
exports.numToLength = numToLength;
/**
 * Safely rounds a number to a character
 * @param {number} num
 * @param {number} len
 * @returns {number}
 */
function round(num, len) {
    len = len || 2;
    return Number(Math.round(Number(num + 'e' + len)) + 'e-' + len);
}
exports.round = round;
/**
 * Format a number
 *
 * @example
 * splitRange(21257.32, {separator: ','}) // returns '21 257,32'
 *
 * @example
 * splitRange(21257.322, {separator: ','}, (num) => round(num, 2)) // returns '21 257,32'
 *
 * @param {number} num
 * @param {ISplitRangeOptions} options format options
 * @param {IFilter<number, number>} processor function for preprocess param
 * @returns {string}
 */
function splitRange(num, options, processor) {
    if (processor) {
        num = processor(num);
    }
    var str = String(num);
    var numData = str.split('.');
    var integral = numData[0], fractional = numData[1];
    integral = integral.split('').reverse().join('');
    integral = integral.replace(/(\d{3})/g, '$1 ')
        .split('').reverse().join('').replace(/\s/g, options && options.nbsp ? '&nbsp;' : ' ').trim();
    if (fractional) {
        return integral + (options && options.separator || exports.DEFAULT_NUMBER_SEPARATOR) + fractional;
    }
    return integral;
}
exports.splitRange = splitRange;
/**
 * A generic iterator function, which can be used to seamlessly iterate over objects.
 * Like forEach for array
 * @param {Array<T> | IHash<T>} param
 * @param {(data: T, key: (string | number))} callback
 * @param context
 */
function each(param, callback, context) {
    if (typeof param !== 'object' || !param) {
        return null;
    }
    if (context) {
        return Array.isArray(param) ? param.forEach(callback, context) :
            Object.keys(param).forEach(function (key) { return callback.call(context, param[key], key); });
    }
    else {
        return Array.isArray(param) ? param.forEach(callback) :
            Object.keys(param).forEach(function (key) { return callback(param[key], key); });
    }
}
exports.each = each;
/**
 * The general iterator function that can be used to test a particular property.
 * Like some for array
 * @param {Object} param
 * @param {ISomeCallback<T>} callback
 * @returns {boolean}
 */
function some(param, callback) {
    return Object.keys(param).some(function (key) { return callback(param[key], key); });
}
exports.some = some;
/**
 * Get some data from object by string path
 *
 * @example
 * get({a: {b: 1}}), 'a.b') // returns 1
 *
 * @param {Object} data
 * @param {string} path
 * @returns {T}
 */
function get(data, path) {
    var tmp = data;
    var parts = isString(path) ? Path_1.Path.parse(path) : path;
    parts.some(function (item) {
        if (typeof tmp === 'object' && tmp !== null && (item.name in tmp)) {
            tmp = tmp[item.name];
        }
        else {
            tmp = null;
            return true;
        }
    });
    return tmp;
}
exports.get = get;
/**
 * Set some data to object by string path
 *
 * @example
 * var some = {};
 * set(some), 'a.b', 1) // some equal {a: {b: 1}}
 *
 * @param {Object} data
 * @param {string} path
 * @param value
 */
function set(data, path, value) {
    var tmp = data;
    var parts = isString(path) ? Path_1.Path.parse(path) : path;
    parts.forEach(function (itemData, index) {
        var isLast = index === parts.length - 1;
        if (isLast) {
            tmp[itemData.name] = value;
        }
        else {
            if (typeof tmp[itemData.name] !== 'object') {
                tmp[itemData.name] = itemData.nextContainer;
            }
            tmp = tmp[itemData.name];
        }
    });
}
exports.set = set;
function getLayers(data, path) {
    var tmp = data;
    var layers = [{ name: null, data: data, parent: null }];
    var parts = isString(path) ? Path_1.Path.parse(path) : path;
    parts.forEach(function (item) {
        if (tmp) {
            layers.push({ name: item.name, data: tmp[item.name], parent: tmp });
            tmp = tmp[item.name];
        }
        else {
            layers = null;
        }
    });
    return layers;
}
exports.getLayers = getLayers;
function unset(data, path) {
    (getLayers(data, path) || []).reverse().some(function (item, index) {
        if (index === 0) {
            if (item.parent) {
                delete item.parent[item.name];
            }
        }
        else {
            if (item.parent && Object.keys(item.data).length === 0) {
                delete item.parent[item.name];
            }
        }
    });
}
exports.unset = unset;
var counter = 0;
function uniqueId(prefix) {
    if (prefix === void 0) { prefix = ''; }
    return "" + prefix + counter++;
}
exports.uniqueId = uniqueId;
function result(param) {
    if (isFunction(param)) {
        return param();
    }
    else {
        return param;
    }
}
exports.result = result;
/**
 * Get array all path from object
 *
 * @example
 * getPaths({a: {b: 1, c: 2}, d: 1}) // return [['a', 'b'], ['a', 'c'], ['d']]
 *
 * @param {Object} param
 * @returns {Array<Array<string>>}
 */
function getPaths(param) {
    var paths = [];
    function getIterate(parents, array) {
        var iterate = function (value, key) {
            var newLine = parents.slice();
            newLine.push({ type: array ? 1 /* Array */ : 0 /* Object */, name: key });
            if (isObject(value)) {
                each(value, getIterate(newLine));
            }
            else if (isArray(value)) {
                each(value, getIterate(newLine, true));
            }
            else {
                paths.push(newLine);
            }
        };
        return iterate;
    }
    var firstLine = [];
    each(param, getIterate(firstLine, isArray(param)));
    return paths.map(function (pathParts) { return new Path_1.Path(pathParts); });
}
exports.getPaths = getPaths;
function clone(data) {
    switch (typeof data) {
        case 'object':
            if (data === null) {
                return null;
            }
            if (Array.isArray(data)) {
                return data.slice();
            }
            else {
                return __assign({}, data);
            }
        default:
            return data;
    }
}
exports.clone = clone;
function cloneDeep(data) {
    switch (typeof data) {
        case 'object':
            var paths = getPaths(data);
            var $clone_1 = isArray(data) ? [] : Object.create(null);
            paths.forEach(function (path) {
                var value = get(data, path);
                set($clone_1, path, value);
            });
            return $clone_1;
        default:
            return data;
    }
}
exports.cloneDeep = cloneDeep;
function merge(origin) {
    var args = [];
    for (var _i = 1; _i < arguments.length; _i++) {
        args[_i - 1] = arguments[_i];
    }
    args.forEach(function (part) {
        var paths = getPaths(part);
        paths.forEach(function (path) {
            var value = get(part, path);
            set(origin, path, value);
        });
    });
    return origin;
}
exports.merge = merge;
function defaults(target) {
    var args = [];
    for (var _i = 1; _i < arguments.length; _i++) {
        args[_i - 1] = arguments[_i];
    }
    var paths = getPaths(target).map(String);
    args.reverse().forEach(function (item) {
        var itemPaths = getPaths(item);
        itemPaths.forEach(function (path) {
            var stringPath = path.toString();
            if (paths.indexOf(stringPath) === -1) {
                paths.push(stringPath);
                set(target, path, get(item, path));
            }
        });
    });
    return target;
}
exports.defaults = defaults;
//# sourceMappingURL=utils.js.map