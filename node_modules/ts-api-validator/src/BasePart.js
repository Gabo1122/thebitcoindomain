"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const ts_utils_1 = require("ts-utils");
class BasePart {
    constructor(options, path) {
        this.options = options;
        this.path = path;
        if (this.options.isEmpty) {
            this.isEmpty = this.options.isEmpty;
        }
        if (this.options.isValid) {
            this.isValid = this.options.isValid;
        }
        if (this.options.required && ('defaultValue' in this.options)) {
            throw new Error('Wrong params! Conflict options "required" and defaultValue');
        }
    }
    process(data, roots) {
        const path = this.getPath();
        const result = this.getValue(this.getDataByPath(data, path), roots);
        return BasePart.toPromise(result).then((value) => {
            const isEmpty = this.isEmpty(value);
            const isValid = this.isValid(value);
            const type = this.options.type.name || this.options.type.prototype.constructor.name;
            if (this.options.required) {
                if (isEmpty) {
                    throw new Error(`Required field type "${type}" "${path}" is empty!`);
                }
            }
            if (('defaultValue' in this.options) && isEmpty) {
                value = this.options.defaultValue;
            }
            else {
                if (!isValid) {
                    throw new Error(`Field "${path}" is invalid!`);
                }
            }
            return value;
        });
    }
    getPath() {
        return this.options.path === null ? null : this.options.path || this.path;
    }
    isEmpty(data) {
        return data == null;
    }
    isValid(data) {
        return true;
    }
    getDataByPath(data, path) {
        if (this.options.parseValue) {
            if (path) {
                return this.options.parseValue(ts_utils_1.get(data, path));
            }
            else {
                return this.options.parseValue(data);
            }
        }
        else if (path != null) {
            return ts_utils_1.get(data, path);
        }
        else {
            return data;
        }
    }
    static isPromise(some) {
        return some && some.then && typeof some.then === 'function';
    }
    static toPromise(some) {
        return BasePart.isPromise(some) ? some : Promise.resolve(some);
    }
}
exports.BasePart = BasePart;
