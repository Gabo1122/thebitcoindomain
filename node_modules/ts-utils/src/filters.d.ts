export declare function filterList<T>(...filters: Array<IFilter<T, boolean>>): IFilter<T, boolean>;
export declare function not<T>(processor?: IProcessor<T>): IFilter<T, boolean>;
export declare function empty<T>(options?: IEmptyFilterOptions): IFilter<T, boolean>;
export declare function contains<T>(data: Partial<T>): IFilter<T, boolean>;
export declare function containsDeep<T extends object>(data: Partial<T>): IFilter<T, boolean>;
export declare function notContains<T>(data: Partial<T>): IFilter<T, boolean>;
export declare function notContainsDeep<T extends object>(data: Partial<T>): IFilter<T, boolean>;
export declare function roundFilter(len?: number): IFilter<number, number>;
export declare function splitRangeFilter(processor?: IFilter<number | string, number | string>, separator?: string): IFilter<number | string, string>;
export declare function roundSplit(len?: number, separator?: string): IFilter<number, string>;
export declare function equal<T>(some: T, noStrict?: boolean): IFilter<T, boolean>;
export declare function notEqual<T>(some: T, noStrict?: boolean): IFilter<T, boolean>;
export declare function date(pattern: string, processor?: IFilter<any, Date | number>): IFilter<any, string>;
export declare function getBinaryFilter<T extends object>(data: Partial<T>): IBinaryFilter<T>;
export interface IBinaryFilter<T> {
    (data: T): -1 | 0 | 1;
}
export interface date {
    (pattern: string): IFilter<Date | number, string>;
    (pattern: string, processor: IFilter<any, number | Date>): IFilter<any, string>;
}
export interface IProcessor<T> {
    (data: T): any;
}
export interface IFilter<P, R> {
    (data: P): R;
}
export interface IEmptyFilterOptions {
    skipNumber?: boolean;
    skipString?: boolean;
    skipNotEmpty?: boolean;
    skipNull?: boolean;
    skipUndefined?: boolean;
}
