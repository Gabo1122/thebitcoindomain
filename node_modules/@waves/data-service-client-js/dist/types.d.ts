import { Asset, Candle, AssetPair } from '@waves/data-entities';
import { BigNumber } from '@waves/bignumber';
export declare enum ApiTypes {
    List = "list",
    Asset = "asset",
    Pair = "pair",
    Transaction = "transaction",
    Alias = "alias",
    Candle = "candle"
}
export declare enum HttpMethods {
    Get = "GET",
    Post = "POST"
}
export interface ILibRequest {
    url: string;
    method: HttpMethods;
    headers?: {};
    body?: {};
}
export interface ILibOptions {
    rootUrl: string;
    parse?: TParser;
    fetch?: TFunction<any>;
    transform?: TFunction<any>;
}
export declare type TListResponseJSON<T> = {
    __type: ApiTypes.List;
    data: T[];
};
export declare type TResponse<T> = Promise<{
    data: T;
    fetchMore?: TFunction<TResponse<T>>;
}>;
export declare type TCreateGetFn<T> = (libOptions: ILibOptions) => T;
export declare type TPredicate = (...args: any[]) => boolean;
export declare type TFunction<T> = (...args: any[]) => T;
export declare type TParser = (text: string) => any;
export interface ITransaction {
}
export interface IExchangeTxFilters {
    timeStart?: string | Date | number;
    timeEnd?: string | Date | number;
    matcher?: string;
    sender?: string;
    amountAsset?: string | Asset;
    priceAsset?: string | Asset;
    limit?: number;
    sort?: string;
}
export interface ITransferTxFilters {
    sender?: string;
    recipient?: string;
    assetId?: string;
    timeStart?: string | Date | number;
    timeEnd?: string | Date | number;
    limit?: number;
    sort?: string;
}
export interface IMassTransferTxFilters {
    sender?: string;
    recipient?: string;
    assetId?: string;
    timeStart?: string | Date | number;
    timeEnd?: string | Date | number;
    limit?: number;
    sort?: string;
}
export interface IGetExchangeTxs {
    (filters: IExchangeTxFilters): TResponse<ITransaction[]>;
    (id: string): TResponse<ITransaction>;
    (): TResponse<ITransaction[]>;
}
export interface IGetTransferTxs {
    (filters: ITransferTxFilters): TResponse<ITransaction[]>;
    (id: string): TResponse<ITransaction>;
    (): TResponse<ITransaction[]>;
}
export interface IGetMassTransferTxs {
    (filters: IMassTransferTxFilters): TResponse<ITransaction[]>;
    (id: string): TResponse<ITransaction>;
    (): TResponse<ITransaction[]>;
}
export declare type TAssetId = string;
export declare type TGetAssets = (...ids: TAssetId[]) => TResponse<Asset[]>;
export declare type TGetAssetsByTicker = (ticker: string) => TResponse<Asset[]>;
export declare type TAliasId = string;
export declare type TAlias = {
    address: string;
    alias: string;
};
export declare type TAliasesByAddressOptions = {
    showBroken?: boolean;
};
export declare type TAliasesByAddressParams = [string, TAliasesByAddressOptions];
export declare type TAliases = {
    getById: TGetAliasById;
    getByAddress: TGetAliasesByAddress;
};
export declare type TGetAliasById = (id: TAliasId) => TResponse<TAlias[]>;
export declare type TGetAliasesByAddress = (address: string, options?: TAliasesByAddressOptions) => TResponse<TAlias[]>;
export declare type TCandlesParams = {
    timeStart: string | Date | number;
    timeEnd?: string | Date | number;
    interval: string;
    matcher: string;
};
export declare type TCandlesRequestFilters = [string, string, TCandlesParams];
export declare type TGetCandles = (amountAsset: string, priceAsset: string, params: TCandlesParams) => TResponse<Candle[]>;
export declare type TPairsRequest = [string, AssetPair[]];
export declare type TPairJSON = {
    firstPrice: BigNumber;
    lastPrice: BigNumber;
    volume: BigNumber;
    amountAsset: string;
    priceAsset: string;
};
export declare type TGetPairs = (matcher: string) => (pairs: AssetPair[]) => TResponse<TPairJSON[]>;
