export { seedWordsList } from './crypto/seed-words-list';
export { ChaidId } from './extensions/chain-id';
export { Seed } from './extensions/seed';
export { isPrivateKey, isPublicKey } from './crypto/util';
export { crypto } from './crypto/crypto';
export * from './crypto/interface';
export declare const signBytes: (seedOrPrivateKey: string | Uint8Array | number[] | import("./crypto/interface").TRawStringInDiscriminator | import("./crypto/interface").INonceSeed | import("./crypto/interface").TPrivateKey<import("./crypto/interface").TBinaryIn>, bytes: import("./crypto/interface").TBinaryIn, random?: string | Uint8Array | number[] | undefined) => string, keyPair: (seed: import("./crypto/interface").TSeed) => import("./crypto/interface").TKeyPair<string>, publicKey: (seedOrPrivateKey: string | Uint8Array | number[] | import("./crypto/interface").TRawStringInDiscriminator | import("./crypto/interface").INonceSeed | import("./crypto/interface").TPrivateKey<import("./crypto/interface").TBinaryIn>) => string, privateKey: (seed: import("./crypto/interface").TSeed) => string, address: (seedOrPublicKey: string | Uint8Array | number[] | import("./crypto/interface").TRawStringInDiscriminator | import("./crypto/interface").INonceSeed | import("./crypto/interface").TPublicKey<import("./crypto/interface").TBinaryIn>, chainId?: string | number | undefined) => string, blake2b: (input: import("./crypto/interface").TBinaryIn) => Uint8Array, keccak: (input: import("./crypto/interface").TBinaryIn) => Uint8Array, sha256: (input: import("./crypto/interface").TBinaryIn) => Uint8Array, sharedKey: (privateKeyFrom: import("./crypto/interface").TBinaryIn, publicKeyTo: import("./crypto/interface").TBinaryIn, prefix: import("./crypto/interface").TRawStringIn) => string, seedWithNonce: (seed: import("./crypto/interface").TSeed, nonce: number) => import("./crypto/interface").INonceSeed, base64Encode: (input: import("./crypto/interface").TBinaryIn) => string, base64Decode: (input: string) => Uint8Array, base58Encode: (input: import("./crypto/interface").TBinaryIn) => string, base58Decode: (input: string) => Uint8Array, base16Encode: (input: import("./crypto/interface").TBinaryIn) => string, base16Decode: (input: string) => Uint8Array, stringToBytes: (input: string, encoding?: "utf8" | "raw" | undefined) => Uint8Array, bytesToString: (input: import("./crypto/interface").TBinaryIn, encoding?: "utf8" | "raw" | undefined) => string, random: <T extends "Array8" | "Array16" | "Array32" | "Buffer" | "Uint8Array" | "Uint16Array" | "Uint32Array">(count: number, type: T) => import("./crypto/interface").TRandomTypesMap[T], randomSeed: (wordsCount?: number | undefined) => string, randomBytes: (size: number) => Uint8Array, verifySignature: (publicKey: import("./crypto/interface").TBinaryIn, bytes: import("./crypto/interface").TBinaryIn, signature: import("./crypto/interface").TBinaryIn) => boolean, verifyPublicKey: (publicKey: import("./crypto/interface").TBinaryIn) => boolean, verifyAddress: (address: import("./crypto/interface").TBinaryIn, optional?: {
    chainId?: string | number | undefined;
    publicKey?: string | Uint8Array | number[] | undefined;
} | undefined) => boolean, messageDecrypt: (sharedKey: import("./crypto/interface").TBinaryIn, encryptedMessage: import("./crypto/interface").TBinaryIn) => string, messageEncrypt: (sharedKey: import("./crypto/interface").TBinaryIn, message: string) => Uint8Array, encryptSeed: (seed: string, password: string, encryptionRounds?: number | undefined) => string, decryptSeed: (encryptedSeed: string, password: string, encryptionRounds?: number | undefined) => string, rsaKeyPair: (bits?: number | undefined, e?: number | undefined) => Promise<import("./crypto/interface").TRSAKeyPair>, rsaKeyPairSync: (bits?: number | undefined, e?: number | undefined) => import("./crypto/interface").TRSAKeyPair, rsaSign: (rsaPrivateKey: Uint8Array, message: Uint8Array, digest?: "MD5" | "SHA1" | "SHA224" | "SHA256" | "SHA384" | "SHA512" | "SHA3-224" | "SHA3-256" | "SHA3-384" | "SHA3-512" | undefined) => Uint8Array, rsaVerify: (rsaPublicKey: Uint8Array, message: Uint8Array, signature: Uint8Array, digest?: "MD5" | "SHA1" | "SHA224" | "SHA256" | "SHA384" | "SHA512" | "SHA3-224" | "SHA3-256" | "SHA3-384" | "SHA3-512" | undefined) => boolean, aesDecrypt: (encryptedData: import("./crypto/interface").TBinaryIn, encryptionKey: import("./crypto/interface").TBinaryIn, mode?: "CBC" | "CFB" | "CTR" | "OFB" | "ECB" | "GCM" | undefined, iv?: string | Uint8Array | number[] | undefined) => Uint8Array, aesEncrypt: (data: import("./crypto/interface").TBinaryIn, encryptionKey: import("./crypto/interface").TBinaryIn, mode?: "CBC" | "CFB" | "CTR" | "OFB" | "ECB" | "GCM" | undefined, iv?: string | Uint8Array | number[] | undefined) => Uint8Array, split: (binary: import("./crypto/interface").TBinaryIn, ...sizes: number[]) => Uint8Array[], concat: (...binaries: import("./crypto/interface").TBinaryIn[]) => Uint8Array;
