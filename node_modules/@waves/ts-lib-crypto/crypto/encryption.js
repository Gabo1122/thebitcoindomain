"use strict";
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
Object.defineProperty(exports, "__esModule", { value: true });
var forge = require("node-forge");
var random_1 = require("./random");
var param_1 = require("../conversions/param");
var hashing_1 = require("./hashing");
var concat_split_1 = require("./concat-split");
var axlsign_1 = require("../libs/axlsign");
var string_bytes_1 = require("../conversions/string-bytes");
exports.aesEncrypt = function (data, key, mode, iv) {
    if (mode === void 0) { mode = 'CBC'; }
    var cipher = forge.cipher.createCipher("AES-" + mode, string_bytes_1.bytesToString(param_1._fromIn(key), 'raw'));
    cipher.start({ iv: iv && forge.util.createBuffer(string_bytes_1.bytesToString(param_1._fromIn(iv), 'raw')) });
    cipher.update(forge.util.createBuffer(string_bytes_1.bytesToString(data, 'raw')));
    cipher.finish();
    return string_bytes_1.stringToBytes(cipher.output.getBytes(), 'raw');
};
exports.aesDecrypt = function (encryptedData, key, mode, iv) {
    if (mode === void 0) { mode = 'CBC'; }
    var decipher = forge.cipher.createDecipher("AES-" + mode, string_bytes_1.bytesToString(param_1._fromIn(key), 'raw'));
    decipher.start({ iv: iv && forge.util.createBuffer(string_bytes_1.bytesToString(param_1._fromIn(iv), 'raw')) });
    var encbuf = forge.util.createBuffer(string_bytes_1.bytesToString(param_1._fromIn(encryptedData), 'raw'));
    decipher.update(encbuf);
    if (!decipher.finish()) {
        throw new Error('Failed to decrypt data with provided key');
    }
    return string_bytes_1.stringToBytes(decipher.output.getBytes(), 'raw');
};
exports.messageEncrypt = function (sharedKey, message) {
    var version = Uint8Array.from([1]);
    var CEK = random_1.randomBytes(32);
    var IV = random_1.randomBytes(16);
    var m = string_bytes_1.stringToBytes(message);
    var Cc = exports.aesEncrypt(m, CEK, 'CTR', IV);
    var Ccek = exports.aesEncrypt(CEK, sharedKey, 'ECB');
    var Mhmac = hashing_1.hmacSHA256(m, CEK);
    var CEKhmac = hashing_1.hmacSHA256(concat_split_1.concat(CEK, IV), sharedKey);
    var packageBytes = concat_split_1.concat(version, Ccek, CEKhmac, Mhmac, IV, Cc);
    return packageBytes;
};
exports.messageDecrypt = function (sharedKey, encryptedMessage) {
    var _a = __read(concat_split_1.split(encryptedMessage, 1, 48, 32, 32, 16), 6), version = _a[0], Ccek = _a[1], _CEKhmac = _a[2], _Mhmac = _a[3], iv = _a[4], Cc = _a[5];
    var CEK = exports.aesDecrypt(Ccek, sharedKey, 'ECB');
    var CEKhmac = param_1._fromIn(hashing_1.hmacSHA256(concat_split_1.concat(CEK, iv), param_1._fromIn(sharedKey)));
    var isValidKey = CEKhmac.every(function (v, i) { return v === _CEKhmac[i]; });
    if (!isValidKey)
        throw new Error('Invalid key');
    var M = exports.aesDecrypt(Cc, CEK, 'CTR', iv);
    var Mhmac = param_1._fromIn(hashing_1.hmacSHA256(M, CEK));
    var isValidMessage = Mhmac.every(function (v, i) { return v === _Mhmac[i]; });
    if (!isValidMessage)
        throw new Error('Invalid message');
    return string_bytes_1.bytesToString(M);
};
exports.sharedKey = function (privateKeyFrom, publicKeyTo, prefix) {
    var sharedKey = axlsign_1.default.sharedKey(param_1._fromIn(privateKeyFrom), param_1._fromIn(publicKeyTo));
    var prefixHash = hashing_1.sha256(param_1._fromRawIn(prefix));
    return hashing_1.hmacSHA256(sharedKey, prefixHash);
};
//# sourceMappingURL=encryption.js.map