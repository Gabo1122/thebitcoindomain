"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var interface_1 = require("./interface");
var seed_1 = require("../extensions/seed");
var hashing_1 = require("./hashing");
var param_1 = require("../conversions/param");
var concat_split_1 = require("./concat-split");
var util_1 = require("./util");
var axlsign_1 = require("../libs/axlsign");
exports.seedWithNonce = function (seed, nonce) { return ({ seed: seed_1.Seed.toBinary(seed).seed, nonce: nonce }); };
var buildAddress = function (publicKeyBytes, chainId) {
    if (chainId === void 0) { chainId = interface_1.MAIN_NET_CHAIN_ID; }
    var prefix = [1, typeof chainId === 'string' ? chainId.charCodeAt(0) : chainId];
    var publicKeyHashPart = hashing_1._hashChain(publicKeyBytes).slice(0, 20);
    var rawAddress = concat_split_1.concat(prefix, publicKeyHashPart);
    var addressHash = hashing_1._hashChain(rawAddress).slice(0, 4);
    return concat_split_1.concat(rawAddress, addressHash);
};
var buildSeedHash = function (seedBytes, nonce) {
    var nonceArray = [0, 0, 0, 0];
    if (nonce && nonce > 0) {
        var remainder = nonce;
        for (var i = 3; i >= 0; i--) {
            nonceArray[3 - i] = Math.floor(remainder / Math.pow(2, (i * 8)));
            remainder = remainder % Math.pow(2, (i * 8));
        }
    }
    var seedBytesWithNonce = concat_split_1.concat(nonceArray, seedBytes);
    var seedHash = hashing_1._hashChain(seedBytesWithNonce);
    return hashing_1.sha256(seedHash);
};
exports.keyPair = function (seed) {
    var _a = seed_1.Seed.toBinary(seed), seedBytes = _a.seed, nonce = _a.nonce;
    var seedHash = buildSeedHash(seedBytes, nonce);
    var keys = axlsign_1.default.generateKeyPair(seedHash);
    return {
        privateKey: keys.private,
        publicKey: keys.public,
    };
};
exports.address = function (seedOrPublicKey, chainId) {
    if (chainId === void 0) { chainId = interface_1.MAIN_NET_CHAIN_ID; }
    return util_1.isPublicKey(seedOrPublicKey) ?
        buildAddress(param_1._fromIn(seedOrPublicKey.publicKey), chainId) :
        exports.address(exports.keyPair(seedOrPublicKey), chainId);
};
exports.publicKey = function (seedOrPrivateKey) {
    return util_1.isPrivateKey(seedOrPrivateKey) ?
        axlsign_1.default.generateKeyPair(param_1._fromIn(seedOrPrivateKey.privateKey)).public :
        exports.keyPair(seedOrPrivateKey).publicKey;
};
exports.privateKey = function (seed) {
    return exports.keyPair(seed).privateKey;
};
//# sourceMappingURL=address-keys-seed.js.map