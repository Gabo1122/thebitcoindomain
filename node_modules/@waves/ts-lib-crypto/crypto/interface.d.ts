/// <reference types="node" />
export declare const PUBLIC_KEY_LENGTH = 32;
export declare const PRIVATE_KEY_LENGTH = 32;
export declare const SIGNATURE_LENGTH = 64;
export declare const ADDRESS_LENGTH = 26;
export declare const MAIN_NET_CHAIN_ID = 87;
export declare const TEST_NET_CHAIN_ID = 84;
export interface INonceSeed {
    seed: TBytes;
    nonce?: number;
}
export declare type AESMode = 'CBC' | 'CFB' | 'CTR' | 'OFB' | 'ECB' | 'GCM';
export declare type RSADigestAlgorithm = 'MD5' | 'SHA1' | 'SHA224' | 'SHA256' | 'SHA384' | 'SHA512' | 'SHA3-224' | 'SHA3-256' | 'SHA3-384' | 'SHA3-512';
export declare type TRandomTypesMap = {
    Array8: number[];
    Array16: number[];
    Array32: number[];
    Buffer: Buffer;
    Uint8Array: Uint8Array;
    Uint16Array: Uint16Array;
    Uint32Array: Uint32Array;
};
export declare type TBytes = Uint8Array;
export declare type TBase64 = string;
export declare type TBase58 = string;
export declare type TBase16 = string;
export declare type TChainId = string | number;
export declare type TBinaryIn = TBytes | TBase58 | number[];
export declare type TRawStringInDiscriminator = {
    TRawStringIn: null;
};
export declare type TRawStringIn = TBytes | string | number[] | TRawStringInDiscriminator;
export declare type TBinaryOut = TBytes | TBase58;
export declare type TPublicKey<T extends TBinaryIn = TBase58> = {
    publicKey: T;
};
export declare type TPrivateKey<T extends TBinaryIn = TBase58> = {
    privateKey: T;
};
export declare type TKeyPair<T extends TBinaryIn = TBase58> = TPublicKey<T> & TPrivateKey<T>;
export declare type TSeed = TRawStringIn | INonceSeed;
export declare type TRSAKeyPair = {
    rsaPublic: TBytes;
    rsaPrivate: TBytes;
};
export interface ISeedRelated<TDesiredOut extends TBinaryOut = TBase58> {
    seedWithNonce: (seed: TSeed, nonce: number) => INonceSeed;
    keyPair: (seed: TSeed) => TKeyPair<TDesiredOut>;
    publicKey: (seedOrPrivateKey: TSeed | TPrivateKey<TBinaryIn>) => TDesiredOut;
    privateKey: (seed: TSeed) => TDesiredOut;
    address: (seedOrPublicKey: TSeed | TPublicKey<TBinaryIn>, chainId?: TChainId) => TDesiredOut;
    signBytes: (seedOrPrivateKey: TSeed | TPrivateKey<TBinaryIn>, bytes: TBinaryIn, random?: TBinaryIn) => TDesiredOut;
}
export interface ISeedEmbeded<TDesiredOut extends TBinaryOut = TBase58> {
    seedWithNonce: (nonce: number) => INonceSeed;
    keyPair: () => TKeyPair<TDesiredOut>;
    publicKey: () => TDesiredOut;
    privateKey: () => TDesiredOut;
    address: (chainId?: TChainId) => TDesiredOut;
    signBytes: (bytes: TBinaryIn, random?: TBinaryIn) => TDesiredOut;
}
export interface IWavesCrypto<TDesiredOut extends TBinaryOut = TBase58> {
    blake2b: (input: TBinaryIn) => TBytes;
    keccak: (input: TBinaryIn) => TBytes;
    sha256: (input: TBinaryIn) => TBytes;
    base64Encode: (input: TBinaryIn) => TBase64;
    base64Decode: (input: TBase64) => TBytes;
    base58Encode: (input: TBinaryIn) => TBase58;
    base58Decode: (input: TBase58) => TBytes;
    base16Encode: (input: TBinaryIn) => TBase16;
    base16Decode: (input: TBase16) => TBytes;
    stringToBytes: (input: string, encoding?: 'utf8' | 'raw') => TBytes;
    bytesToString: (input: TBinaryIn, encoding?: 'utf8' | 'raw') => string;
    split: (binary: TBinaryIn, ...sizes: number[]) => TBytes[];
    concat: (...binaries: TBinaryIn[]) => TBytes;
    random<T extends keyof TRandomTypesMap>(count: number, type: T): TRandomTypesMap[T];
    randomBytes: (size: number) => TBytes;
    randomSeed: (wordsCount?: number) => string;
    verifySignature: (publicKey: TBinaryIn, bytes: TBinaryIn, signature: TBinaryIn) => boolean;
    verifyPublicKey: (publicKey: TBinaryIn) => boolean;
    verifyAddress: (address: TBinaryIn, optional?: {
        chainId?: TChainId;
        publicKey?: TBinaryIn;
    }) => boolean;
    sharedKey: (privateKeyFrom: TBinaryIn, publicKeyTo: TBinaryIn, prefix: TRawStringIn) => TDesiredOut;
    messageDecrypt: (sharedKey: TBinaryIn, encryptedMessage: TBinaryIn) => string;
    messageEncrypt: (sharedKey: TBinaryIn, message: string) => TBytes;
    aesEncrypt: (data: TBinaryIn, encryptionKey: TBinaryIn, mode?: AESMode, iv?: TBinaryIn) => TBytes;
    aesDecrypt: (encryptedData: TBinaryIn, encryptionKey: TBinaryIn, mode?: AESMode, iv?: TBinaryIn) => TBytes;
    encryptSeed: (seed: string, password: string, encryptionRounds?: number) => TBase64;
    decryptSeed: (encryptedSeed: TBase64, password: string, encryptionRounds?: number) => string;
    rsaKeyPair: (bits?: number, e?: number) => Promise<TRSAKeyPair>;
    rsaKeyPairSync: (bits?: number, e?: number) => TRSAKeyPair;
    rsaSign: (rsaPrivateKey: TBytes, message: TBytes, digest?: RSADigestAlgorithm) => TBytes;
    rsaVerify: (rsaPublicKey: TBytes, message: TBytes, signature: TBytes, digest?: RSADigestAlgorithm) => boolean;
}
