import { TLong, TMoney } from '../types';
export declare function getAssetId(money: TMoney): string;
export declare function getAssetId(money: TLong | null | undefined): null;
export declare function getAssetId(money: TMoney | TLong | null | undefined): string | null;
export declare function getCoins(money: TMoney | TLong): string;
export declare function getCoins(money: null | undefined): null;
export declare function getCoins(money: TMoney | TLong | undefined | null): string | null;
export declare const curry: ICurry;
export declare const ifElse: <T, Y, N>(expression: (data: T) => boolean, resolve: (data: T) => Y, reject: (data: T) => N) => (data: T) => Y | N;
export declare const has: IHas;
export declare const emptyError: <T>(message: string) => (value: T | null | undefined) => T;
export declare function isOrder<T extends {
    orderType: string;
}>(data: any): data is T;
export declare const length: (some: string | any[]) => number;
export declare const lt: IComparator;
export declare const gt: IComparator;
export declare const lte: IComparator;
export declare const gte: IComparator;
export declare const head: <T>(list: T[]) => T | undefined;
export declare const defaultTo: <T>(value: T) => (data: T | null | undefined) => T;
export declare const map: IMap;
export declare const prop: IProp;
export declare const pipe: IPipe;
interface IComparator {
    (a: number, b: number): boolean;
    (a: number): (b: number) => boolean;
}
interface IHas {
    <T extends {
        [Key: string]: any;
    }>(prop: string | number | symbol, data: T): prop is keyof T;
    <K extends keyof any, T extends {
        [Key: string]: any;
    }>(prop: K): (data: T) => boolean;
}
interface IMap {
    <T, R>(cb: (item: T) => R, list: Array<T>): Array<R>;
    <T, R>(cb: (item: T) => R): (list: Array<T>) => Array<R>;
}
interface IPipe {
    <A, B>(cb1: (a: A) => B): (a: A) => B;
    <A, B, R>(cb1: (a: A) => B, cb2: (b: B) => R): (a: A) => R;
    <A, B, C, R>(cb1: (a: A) => B, cb2: (b: B) => C, cb3: (c: C) => R): (a: A) => R;
    <A, B, C, D, R>(cb1: (a: A) => B, cb2: (b: B) => C, cb3: (c: C) => D, cb4: (c: D) => R): (a: A) => R;
    <A, B, C, D, E, R>(cb1: (a: A) => B, cb2: (b: B) => C, cb3: (c: C) => D, cb4: (c: D) => E, cb5: (data: E) => R): (a: A) => R;
}
interface IProp {
    <T, K extends keyof T>(key: K, data: T): T[K];
    <T, K extends keyof T>(key: K): (data: T) => T[K];
}
interface ICurry {
    <A, B, R>(cb: (a: A, b: B) => R): (a: A, b: B) => R;
    <A, B, R>(cb: (a: A, b: B) => R): (a: A) => (b: B) => R;
    <A, B, C, R>(cb: (a: A, b: B, c: C) => R): (a: A, b: B, c: C) => R;
    <A, B, C, R>(cb: (a: A, b: B, c: C) => R): (a: A, b: B) => (c: C) => R;
    <A, B, C, R>(cb: (a: A, b: B, c: C) => R): (a: A) => (b: B) => (c: C) => R;
}
export {};
