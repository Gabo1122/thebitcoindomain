import { IAliasTransaction, IBurnTransaction, ICancelLeaseTransaction, IDataTransaction, IExchangeTransaction, IIssueTransaction, ILeaseTransaction, IMassTransferTransaction, IReissueTransaction, ISetAssetScriptTransaction, ISetScriptTransaction, ISponsorshipTransaction, ITransferTransaction, TTransaction, IExchangeTransactionOrderWithProofs, IMassTransferItem, TDataTransactionEntry, IInvokeScriptCall, IInvokeScriptTransaction, IInvokeScriptPayment, TInvokeScriptCallArgument } from '@waves/ts-types';
import { TYPES } from '../constants';
declare type TConvertMap<TO, T extends TTransaction<any>> = {
    [TYPES.ISSUE]: TReplaceParam<T, 'fee' | 'quantity', TO>;
    [TYPES.TRANSFER]: TReplaceParam<T, 'fee' | 'amount', TO>;
    [TYPES.REISSUE]: TReplaceParam<T, 'fee' | 'quantity', TO>;
    [TYPES.BURN]: TReplaceParam<T, 'fee' | 'quantity', TO>;
    [TYPES.EXCHANGE]: TReplaceParam<T, 'fee' | 'buyOrder' | 'sellOrder' | 'amount' | 'price' | 'sellMatcherFee' | 'buyMatcherFee', TO>;
    [TYPES.LEASE]: TReplaceParam<T, 'fee' | 'amount', TO>;
    [TYPES.CANCEL_LEASE]: TReplaceParam<T, 'fee', TO>;
    [TYPES.ALIAS]: TReplaceParam<T, 'fee', TO>;
    [TYPES.MASS_TRANSFER]: T extends IMassTransferTransaction<any> ? TReplaceParam<TReplaceParam<T, 'fee', TO>, 'transfers', Array<IMassTransferItem<TO>>> : never;
    [TYPES.DATA]: T extends IDataTransaction<any> ? TReplaceParam<TReplaceParam<T, 'fee', TO>, 'data', Array<TDataTransactionEntry<TO>>> : never;
    [TYPES.SET_SCRIPT]: TReplaceParam<T, 'fee', TO>;
    [TYPES.SPONSORSHIP]: TReplaceParam<T, 'fee' | 'minSponsoredAssetFee', TO>;
    [TYPES.SET_ASSET_SCRIPT]: TReplaceParam<T, 'fee', TO>;
    [TYPES.INVOKE_SCRIPT]: TReplaceParam<TReplaceParam<TReplaceParam<T, 'fee', TO>, 'payment', Array<IInvokeScriptPayment<TO>>>, 'call', IInvokeScriptCall<TO>>;
};
declare type TReplaceParam<T, KEYS, NEW_VALUE> = {
    [Key in keyof T]: Key extends KEYS ? NEW_VALUE : T[Key];
};
export declare const issue: <FROM, TO, TX extends IIssueTransaction<FROM>>(tx: TX, factory: IFactory<FROM, TO>) => TReplaceParam<TX, "fee", TO> & {
    quantity: TO;
};
export declare const transfer: <FROM, TO, TX extends ITransferTransaction<FROM>>(tx: TX, factory: IFactory<FROM, TO>) => TReplaceParam<TX, "fee", TO> & {
    amount: TO;
};
export declare const reissue: <FROM, TO, TX extends IReissueTransaction<FROM>>(tx: TX, factory: IFactory<FROM, TO>) => TReplaceParam<TX, "fee", TO> & {
    quantity: TO;
};
export declare const burn: <FROM, TO, TX extends IBurnTransaction<FROM>>(tx: TX, factory: IFactory<FROM, TO>) => TReplaceParam<TX, "fee", TO> & {
    quantity: TO;
};
export declare const order: <FROM, TO, O extends IExchangeTransactionOrderWithProofs<FROM>>(data: O, factory: IFactory<FROM, TO>) => TReplaceParam<O, "amount" | "price" | "matcherFee", TO>;
export declare const exchange: <FROM, TO, TX extends IExchangeTransaction<FROM>>(tx: TX, factory: IFactory<FROM, TO>) => TReplaceParam<TX, "fee", TO> & {
    buyOrder: TReplaceParam<import("@waves/ts-types/src").IExchangeTransactionOrder<FROM> & import("@waves/ts-types/src").IWithProofs, "amount" | "price" | "matcherFee", TO>;
    sellOrder: TReplaceParam<import("@waves/ts-types/src").IExchangeTransactionOrder<FROM> & import("@waves/ts-types/src").IWithProofs, "amount" | "price" | "matcherFee", TO>;
    amount: TO;
    price: TO;
    sellMatcherFee: TO;
    buyMatcherFee: TO;
};
export declare const lease: <FROM, TO, TX extends ILeaseTransaction<FROM>>(tx: TX, factory: IFactory<FROM, TO>) => TReplaceParam<TX, "fee", TO> & {
    amount: TO;
};
export declare const cancelLease: <FROM, TO, TX extends ICancelLeaseTransaction<FROM>>(tx: TX, factory: IFactory<FROM, TO>) => TReplaceParam<TX, "fee", TO>;
export declare const alias: <FROM, TO, TX extends IAliasTransaction<FROM>>(tx: TX, factory: IFactory<FROM, TO>) => TReplaceParam<TX, "fee", TO>;
export declare const massTransfer: <FROM, TO, TX extends IMassTransferTransaction<FROM>>(tx: TX, factory: IFactory<FROM, TO>) => TReplaceParam<TX, "fee", TO> & {
    transfers: {
        amount: TO;
        recipient: string;
    }[];
};
export declare const data: <FROM, TO, TX extends IDataTransaction<FROM>>(tx: TX, factory: IFactory<FROM, TO>) => TReplaceParam<TX, "fee", TO> & {
    data: (import("@waves/ts-types/src").IDataTransactionEntryBoolean | import("@waves/ts-types/src").IDataTransactionEntryString | import("@waves/ts-types/src").IDataTransactionEntryBinary | {
        value: TO;
        key: string;
        type: "integer";
    })[];
};
export declare const setScript: <FROM, TO, TX extends ISetScriptTransaction<FROM>>(tx: TX, factory: IFactory<FROM, TO>) => TReplaceParam<TX, "fee", TO>;
export declare const sponsorship: <FROM, TO, TX extends ISponsorshipTransaction<FROM>>(tx: TX, factory: IFactory<FROM, TO>) => TReplaceParam<TX, "fee", TO> & {
    minSponsoredAssetFee: TO;
};
export declare const invokeScript: <FROM, TO, TX extends IInvokeScriptTransaction<FROM>>(tx: TX, factory: IFactory<FROM, TO>) => TReplaceParam<TX, "fee", TO> & {
    payment: {
        amount: TO;
        assetId: string;
    }[] | null | undefined;
    call: {
        args: TInvokeScriptCallArgument<TO>[] | null | undefined;
    } | {
        args: TInvokeScriptCallArgument<TO>[] | null | undefined;
    } | {
        args: TInvokeScriptCallArgument<TO>[] | null | undefined;
        function: string;
    };
};
export declare const setAssetScript: <FROM, TO, TX extends ISetAssetScriptTransaction<FROM>>(tx: TX, factory: IFactory<FROM, TO>) => TReplaceParam<TX, "fee", TO>;
export declare function convert<FROM, TO, TX extends TTransaction<FROM>, TYPE extends TX['type'] = TX['type']>(tx: TX, factory: IFactory<FROM, TO>): TConvertMap<TO, TX>[TYPE];
export declare function convert<FROM, TO, TX extends IExchangeTransactionOrderWithProofs<FROM>>(tx: TX, factory: IFactory<FROM, TO>): TReplaceParam<TX, 'price' | 'amount' | 'matcherFee', TO>;
interface IFactory<FROM, TO> {
    (long: FROM): TO;
}
export {};
