"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var data_entities_1 = require("@waves/data-entities");
var bignumber_1 = require("@waves/bignumber");
var waves_transactions_1 = require("@waves/waves-transactions");
var fieldValidator_1 = require("./fieldValidator");
exports.WAVES_ID = 'WAVES';
var _a = waves_transactions_1.libs.crypto, stringToBytes = _a.stringToBytes, base58Encode = _a.base58Encode;
var normalizeAssetId = function (id) { return id === exports.WAVES_ID ? '' : id; };
var prepare;
(function (prepare) {
    var processors;
    (function (processors) {
        function callFunc(callData) {
            if (!callData) {
                return null;
            }
            return {
                function: callData && callData.function || '',
                args: callData && callData.args || [],
            };
        }
        processors.callFunc = callFunc;
        function payments(payments) {
            return (payments || []).map(function (pay) {
                return {
                    amount: toBigNumber(pay).toString(),
                    assetId: moneyToNodeAssetId(pay)
                };
            });
        }
        processors.payments = payments;
        function paymentsToNode(payments) {
            return (payments || []).map(function (pay) {
                return {
                    amount: toBigNumber(pay),
                    assetId: moneyToNodeAssetId(pay) || null,
                };
            });
        }
        processors.paymentsToNode = paymentsToNode;
        function scriptProcessor(code) {
            return !!(code || '').replace('base64:', '') ? code : null;
        }
        processors.scriptProcessor = scriptProcessor;
        function assetPair(data) {
            return {
                amountAsset: normalizeAssetId(data.amount.asset.id),
                priceAsset: normalizeAssetId(data.price.asset.id)
            };
        }
        processors.assetPair = assetPair;
        function signatureFromProof(proofs) {
            return proofs[0];
        }
        processors.signatureFromProof = signatureFromProof;
        function toBigNumber(some) {
            switch (typeof some) {
                case 'string':
                case 'number':
                    return new bignumber_1.BigNumber(some);
                case 'object':
                    if (some instanceof bignumber_1.BigNumber) {
                        return some;
                    }
                    else {
                        return some.getCoins();
                    }
            }
        }
        processors.toBigNumber = toBigNumber;
        function toNumberString(some) {
            return toBigNumber(some).toString();
        }
        processors.toNumberString = toNumberString;
        function toSponsorshipFee(moeny) {
            var coins = moeny.getCoins();
            if (coins.eq(0)) {
                return null;
            }
            else {
                return coins;
            }
        }
        processors.toSponsorshipFee = toSponsorshipFee;
        function moneyToAssetId(money) {
            return money.asset.id;
        }
        processors.moneyToAssetId = moneyToAssetId;
        function moneyToNodeAssetId(money) {
            return idToNode(money.asset.id);
        }
        processors.moneyToNodeAssetId = moneyToNodeAssetId;
        function timestamp(time) {
            if (!(+time) && typeof time === 'string') {
                return Date.parse(time);
            }
            return time && time instanceof Date ? time.getTime() : time;
        }
        processors.timestamp = timestamp;
        function orString(data) {
            return data || '';
        }
        processors.orString = orString;
        function noProcess(data) {
            return data;
        }
        processors.noProcess = noProcess;
        processors.recipient = function (networkByte) { return function (data) {
            return data.length <= 30 ? "alias:" + networkByte + ":" + data : data;
        }; };
        function attachment(data) {
            data = data || '';
            var value = data;
            if (typeof data === 'string') {
                value = stringToBytes(data);
            }
            return base58Encode(Uint8Array.from(value));
        }
        processors.attachment = attachment;
        function addValue(value) {
            return typeof value === 'function' ? value : function () { return value; };
        }
        processors.addValue = addValue;
        function expiration(date) {
            return date || new Date().setDate(new Date().getDate() + 20);
        }
        processors.expiration = expiration;
        function transfers(recipient, amount) {
            return function (transfers) { return transfers.map(function (transfer) { return ({
                recipient: recipient(transfer.recipient),
                amount: amount(transfer.amount)
            }); }); };
        }
        processors.transfers = transfers;
        function quantity(data) {
            return new bignumber_1.BigNumber(data.quantity).mul(new bignumber_1.BigNumber(10).pow(data.precision));
        }
        processors.quantity = quantity;
        function base64(str) {
            return (str || '').replace('base64:', '');
        }
        processors.base64 = base64;
        function toOrderPrice(order) {
            var assetPair = new data_entities_1.AssetPair(order.amount.asset, order.price.asset);
            var orderPrice = data_entities_1.OrderPrice.fromTokens(order.price.toTokens(), assetPair);
            return orderPrice.getMatcherCoins();
        }
        processors.toOrderPrice = toOrderPrice;
    })(processors = prepare.processors || (prepare.processors = {}));
    function wrap(from, to, cb) {
        if (typeof cb != 'function') {
            return { from: from, to: to, cb: function () { return cb; } };
        }
        return { from: from, to: to, cb: cb };
    }
    prepare.wrap = wrap;
    function schema() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        return function (data) { return args.map(function (item) {
            return typeof item === 'string' ? {
                key: item,
                value: processors.noProcess(data[item])
            } : {
                key: item.to,
                value: item.cb(item.from ? data[item.from] : data)
            };
        })
            .reduce(function (result, item) {
            result[item.key] = item.value;
            return result;
        }, Object.create(null)); };
    }
    prepare.schema = schema;
    function signSchema(args) {
        return function (data, validate) {
            if (validate === void 0) { validate = false; }
            var errors = [];
            var prepareData = args.map(function (item) {
                var wrapped = wrap(item.name, item.field, item.processor || processors.noProcess);
                var validateOptions = {
                    key: wrapped.to,
                    value: wrapped.from ? data[wrapped.from] : data,
                    optional: item.optional,
                    optionalData: item.optionalData,
                    type: item.type,
                    name: item.name,
                };
                var validator = fieldValidator_1.VALIDATORS[validateOptions.type];
                try {
                    if (validate && validator) {
                        validator(validateOptions);
                    }
                    return {
                        key: validateOptions.key,
                        value: wrapped.cb(validateOptions.value),
                    };
                }
                catch (e) {
                    errors.push(e);
                }
                return {
                    key: validateOptions.key,
                    value: null,
                };
            })
                .reduce(function (result, _a) {
                var key = _a.key, value = _a.value;
                result[key] = value;
                return result;
            }, Object.create(null));
            if (errors.length) {
                throw new Error(JSON.stringify(errors));
            }
            return prepareData;
        };
    }
    prepare.signSchema = signSchema;
    function idToNode(id) {
        return id === exports.WAVES_ID ? '' : id;
    }
    prepare.idToNode = idToNode;
})(prepare = exports.prepare || (exports.prepare = {}));
//# sourceMappingURL=prepare.js.map