"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e.indexOf(p[i]) < 0)
            t[p[i]] = s[p[i]];
    return t;
};
Object.defineProperty(exports, "__esModule", { value: true });
var waves_transactions_1 = require("@waves/waves-transactions");
var data_entities_1 = require("@waves/data-entities");
var bignumber_1 = require("@waves/bignumber");
var _a = waves_transactions_1.libs.crypto, stringToBytes = _a.stringToBytes, base58Decode = _a.base58Decode, keccak = _a.keccak, blake2b = _a.blake2b;
var TRANSFERS = {
    ATTACHMENT: 140
};
var ALIAS = {
    AVAILABLE_CHARS: '-.0123456789@_abcdefghijklmnopqrstuvwxyz',
    MAX_ALIAS_LENGTH: 30,
    MIN_ALIAS_LENGTH: 4,
};
var ADDRESS = {
    MAX_ADDRESS_LENGTH: 45
};
var ASSETS = {
    NAME_MIN_BYTES: 4,
    NAME_MAX_BYTES: 16,
    DESCRIPTION_MAX_BYTES: 1000,
};
exports.ERROR_MSG = {
    REQUIRED: 'field is required',
    WRONG_TYPE: 'field is wrong type',
    WRONG_NUMBER: 'field is not number',
    WRONG_TIMESTAMP: 'field is not timestamp',
    SMALL_FIELD: 'field is small',
    LARGE_FIELD: 'field is large',
    WRONG_SYMBOLS: 'field has wrong symbols',
    WRONG_ADDRESS: 'field is wrong address',
    WRONG_BOOLEAN: 'field is wrong boolean',
    WRONG_ASSET_ID: 'field is wrong assetId',
    WRONG_ORDER_TYPE: 'field is wrong order type. Field can be "buy" or "sell"',
    NOT_HTTPS_URL: 'field can be url with https protocol',
    BASE64: 'field can be base64 string with prefix "base64:"',
    EMPTY_BASE64: 'field can be not empty base64"',
};
exports.isValidAddress = function (address, networkByte) {
    if (!address || typeof address !== 'string') {
        throw new Error('Missing or invalid address');
    }
    var addressBytes = base58Decode(address);
    if (addressBytes[0] !== 1 || addressBytes[1] !== networkByte) {
        return false;
    }
    var key = addressBytes.slice(0, 22);
    var check = addressBytes.slice(22, 26);
    var keyHash = keccak(blake2b(key)).slice(0, 4);
    for (var i = 0; i < 4; i++) {
        if (check[i] !== keyHash[i]) {
            return false;
        }
    }
    return true;
};
var isBase64 = function (value) {
    if (value === '') {
        return true;
    }
    var regExp = /^([A-Za-z0-9+/]{4})*([A-Za-z0-9+/]{4}|[A-Za-z0-9+/]{3}=|[A-Za-z0-9+/]{2}==)$/;
    return regExp.test(value);
};
var getBytesFromString = function (value) {
    return stringToBytes(value);
};
var numberToString = function (num) { return num && typeof num === 'number' ? num.toString() : num; };
var error = function (_a, message) {
    var value = _a.value, options = __rest(_a, ["value"]);
    var field = options.name, type = options.type;
    throw { value: value, field: field, type: type, message: message };
};
var required = function (options) {
    var value = options.value, optional = options.optional;
    if (!optional && value == null) {
        error(options, exports.ERROR_MSG.REQUIRED);
    }
};
var string = function (options) {
    options = __assign({}, options, { value: numberToString(options.value) });
    required(options);
    var value = options.value, optional = options.optional;
    if ((!optional && value == null) && (value != null && typeof value !== 'string')) {
        return error(options, exports.ERROR_MSG.WRONG_TYPE);
    }
};
var attachment = function (options) {
    var value = options.value;
    if (value == null) {
        return;
    }
    if (typeof value === 'string' || typeof value === 'number') {
        string(options);
        switch (true) {
            case typeof value != 'string':
                error(options, exports.ERROR_MSG.WRONG_TYPE);
                break;
            case getBytesFromString(value).length > TRANSFERS.ATTACHMENT:
                error(options, exports.ERROR_MSG.LARGE_FIELD);
                break;
        }
        return;
    }
    if (typeof value === 'object') {
        switch (true) {
            case typeof value.length !== 'number' || value.length < 0:
                error(options, exports.ERROR_MSG.WRONG_TYPE);
                break;
            case value.length > TRANSFERS.ATTACHMENT:
                error(options, exports.ERROR_MSG.LARGE_FIELD);
                break;
        }
        return;
    }
    error(options, exports.ERROR_MSG.WRONG_TYPE);
};
var number = function (options) {
    required(options);
    var value = options.value;
    if (value != null && new bignumber_1.BigNumber(value).isNaN()) {
        return error(options, exports.ERROR_MSG.WRONG_NUMBER);
    }
};
var boolean = function (options) {
    required(options);
    var value = options.value;
    if (value != null && typeof value !== 'boolean') {
        return error(options, exports.ERROR_MSG.WRONG_BOOLEAN);
    }
};
var money = function (options) {
    required(options);
    var value = options.value;
    if (value == null) {
        return;
    }
    switch (true) {
        case !(value instanceof data_entities_1.Money):
            return error(options, exports.ERROR_MSG.WRONG_TYPE);
        case value instanceof data_entities_1.Money && value.getCoins().isNaN():
            return error(options, exports.ERROR_MSG.WRONG_NUMBER);
    }
};
var numberLike = function (options, min, max) {
    required(options);
    var value = options.value;
    if (value == null) {
        return;
    }
    var checkInterval = function (bigNumber) {
        if (min != null) {
            if (bigNumber.lt(new bignumber_1.BigNumber(min))) {
                error(options, exports.ERROR_MSG.SMALL_FIELD);
            }
        }
        if (max != null) {
            if (bigNumber.gt(new bignumber_1.BigNumber(max))) {
                error(options, exports.ERROR_MSG.LARGE_FIELD);
            }
        }
    };
    switch (true) {
        case value instanceof bignumber_1.BigNumber:
            if (value.isNaN()) {
                error(options, exports.ERROR_MSG.WRONG_TYPE);
            }
            checkInterval(value);
            break;
        case value instanceof data_entities_1.Money:
            var coins = value.getCoins();
            if (coins.isNaN()) {
                error(options, exports.ERROR_MSG.WRONG_NUMBER);
            }
            checkInterval(coins);
            break;
        case typeof value === 'string' && !value:
            error(options, exports.ERROR_MSG.WRONG_NUMBER);
            break;
        case new bignumber_1.BigNumber(value).isNaN():
            return error(options, exports.ERROR_MSG.WRONG_NUMBER);
        default:
            checkInterval(new bignumber_1.BigNumber(value));
    }
};
var aliasName = function (options) {
    options = __assign({}, options, { value: numberToString(options.value) });
    required(options);
    var value = options.value;
    if (value == null) {
        return null;
    }
    switch (true) {
        case typeof value !== 'string':
            return error(options, exports.ERROR_MSG.WRONG_TYPE);
        case value.length < ALIAS.MIN_ALIAS_LENGTH:
            return error(options, exports.ERROR_MSG.SMALL_FIELD);
        case value.length > ALIAS.MAX_ALIAS_LENGTH:
            return error(options, exports.ERROR_MSG.LARGE_FIELD);
        case !(value.split('').every(function (char) { return ALIAS.AVAILABLE_CHARS.includes(char); })):
            return error(options, exports.ERROR_MSG.WRONG_SYMBOLS);
    }
};
var address = function (options) {
    options = __assign({}, options, { value: numberToString(options.value) });
    required(options);
    var value = options.value;
    var validateAddress = function (address) {
        try {
            return exports.isValidAddress(address, options.optionalData);
        }
        catch (e) {
            return false;
        }
    };
    if (value == null) {
        return null;
    }
    switch (true) {
        case typeof value !== 'string':
            return error(options, exports.ERROR_MSG.WRONG_TYPE);
        case value.length <= ALIAS.MAX_ALIAS_LENGTH:
            return error(options, exports.ERROR_MSG.SMALL_FIELD);
        case value.length > ADDRESS.MAX_ADDRESS_LENGTH:
            return error(options, exports.ERROR_MSG.LARGE_FIELD);
        case !validateAddress(value):
            return error(options, exports.ERROR_MSG.WRONG_ADDRESS);
    }
};
var aliasOrAddress = function (options) {
    try {
        aliasName(options);
    }
    catch (e) {
        address(options);
    }
};
var assetId = function (options) {
    options = __assign({}, options, { value: numberToString(options.value) });
    required(options);
    var value = options.value;
    if (value == null) {
        return null;
    }
    if (typeof value !== 'string') {
        return error(options, exports.ERROR_MSG.WRONG_TYPE);
    }
    var isAssetId = false;
    try {
        isAssetId = base58Decode(value.trim()).length === 32;
    }
    catch (e) {
        isAssetId = false;
    }
    if (!isAssetId && value !== 'WAVES') {
        return error(options, exports.ERROR_MSG.WRONG_ASSET_ID);
    }
};
var timestamp = function (options) {
    required(options);
    var value = options.value;
    if (isNaN(value) || value && !(value instanceof Date || typeof value === 'number' || +value)) {
        if (typeof value !== 'string' || isNaN(Date.parse(value))) {
            return error(options, exports.ERROR_MSG.WRONG_TIMESTAMP);
        }
    }
};
var orderType = function (options) {
    required(options);
    var value = options.value;
    if (value == null) {
        return null;
    }
    if (typeof value !== 'string') {
        return error(options, exports.ERROR_MSG.WRONG_TYPE);
    }
    if (value !== 'sell' && value !== 'buy') {
        return error(options, exports.ERROR_MSG.WRONG_ORDER_TYPE);
    }
};
var assetName = function (options) {
    options = __assign({}, options, { value: numberToString(options.value) });
    required(options);
    var value = options.value;
    if (value != null) {
        if (typeof value !== 'string') {
            error(options, exports.ERROR_MSG.WRONG_TYPE);
        }
        var bytesLength = getBytesFromString(value).length;
        if (bytesLength < ASSETS.NAME_MIN_BYTES) {
            error(options, exports.ERROR_MSG.SMALL_FIELD);
        }
        if (bytesLength > ASSETS.NAME_MAX_BYTES) {
            error(options, exports.ERROR_MSG.LARGE_FIELD);
        }
    }
};
var assetDescription = function (options) {
    options = __assign({}, options, { value: numberToString(options.value) });
    required(options);
    var value = options.value;
    if (value != null) {
        if (typeof value !== 'string') {
            error(options, exports.ERROR_MSG.WRONG_TYPE);
        }
        var bytesLength = getBytesFromString(value).length;
        if (bytesLength > ASSETS.DESCRIPTION_MAX_BYTES) {
            error(options, exports.ERROR_MSG.LARGE_FIELD);
        }
    }
};
var precision = function (options) {
    required(options);
    numberLike(options, 0, 8);
};
var httpsUrl = function (options) {
    required(options);
    var value = options.value;
    var isNotUrl = function (url) {
        try {
            new URL(url);
            return false;
        }
        catch (e) {
            return true;
        }
    };
    if (value == null) {
        return null;
    }
    switch (true) {
        case typeof value !== 'string':
            error(options, exports.ERROR_MSG.WRONG_TYPE);
            break;
        case value.indexOf('https://') === -1:
            error(options, exports.ERROR_MSG.NOT_HTTPS_URL);
            break;
        case isNotUrl(value):
            error(options, exports.ERROR_MSG.NOT_HTTPS_URL);
            break;
    }
};
var transfers = function (options) {
    required(options);
    var value = options.value;
    if (!Array.isArray(value)) {
        error(options, exports.ERROR_MSG.WRONG_TYPE);
    }
    if (!options.optional && value.length === 0) {
        error(options, exports.ERROR_MSG.REQUIRED);
    }
    var errors = (value || []).map(function (_a, index) {
        var recipient = _a.recipient, amount = _a.amount, name = _a.name;
        var dataErrors = [];
        try {
            numberLike(__assign({}, options, { value: amount, name: options.name + ":" + index + ":amount", optional: false }));
        }
        catch (e) {
            dataErrors.push(e);
        }
        try {
            aliasOrAddress(__assign({}, options, { value: recipient || name, name: options.name + ":" + index + ":recipient", optional: false }));
        }
        catch (e) {
            dataErrors.push(e);
        }
        return dataErrors;
    }).filter(function (item) { return item.length; });
    if (errors.length) {
        error(options, errors);
        error(options, errors);
    }
};
var data = function (options, noKey) {
    required(options);
    var value = options.value;
    if (!Array.isArray(value)) {
        error(options, exports.ERROR_MSG.WRONG_TYPE);
    }
    var errors = value.map(function (_a, index) {
        var key = _a.key, type = _a.type, value = _a.value;
        if (!noKey) {
            try {
                string(__assign({}, options, { value: key, name: options.name + ":" + index + ":key", optional: false }));
            }
            catch (e) {
                return e;
            }
        }
        var itemOptions = __assign({}, options, { name: options.name + ":" + index + ":value", optional: false, value: value });
        try {
            switch (type) {
                case 'integer':
                    numberLike(itemOptions);
                    break;
                case 'boolean':
                    boolean(itemOptions);
                    break;
                case 'binary':
                    binary(itemOptions);
                    break;
                case 'string':
                    string(itemOptions);
                    break;
                default:
                    error(__assign({}, options, { value: key, name: options.name + ":" + index + ":type" }), exports.ERROR_MSG.WRONG_TYPE);
            }
        }
        catch (e) {
            return e;
        }
    }).filter(function (item) { return item; });
    if (errors.length) {
        error(options, errors);
    }
};
var binary = function (options) {
    var _a = options.value, value = _a === void 0 ? '' : _a;
    if (value && !value.includes('base64:')) {
        error(options, exports.ERROR_MSG.BASE64);
    }
    if (value && !isBase64(value.replace('base64:', ''))) {
        error(options, exports.ERROR_MSG.BASE64);
    }
};
var script = function (options) {
    binary(options);
};
var asset_script = function (options) {
    var value = options.value;
    if (!value || !value.replace('base64:', '')) {
        error(options, exports.ERROR_MSG.EMPTY_BASE64);
    }
    script(options);
};
var call = function (options) {
    required(options);
    var value = options.value;
    if (value == null) {
        return;
    }
    if (!value || typeof value !== 'object') {
        error(options, exports.ERROR_MSG.WRONG_TYPE);
    }
    var functionValue = {
        key: 'call.function',
        value: value.function,
        optional: false,
        type: 'string',
        name: 'function'
    };
    string(functionValue);
    var argsValue = {
        key: 'call.args',
        value: value.args,
        optional: true,
        type: 'args',
        name: 'args'
    };
    if (argsValue.value) {
        data(argsValue, true);
    }
};
var payment = function (options) {
    required(options);
    var value = options.value;
    if (typeof value !== 'object' || typeof value.length !== 'number' || !value.forEach) {
        error(options, exports.ERROR_MSG.WRONG_TYPE);
    }
    var errors = (value || []).map(function (amount, index) {
        var dataErrors = [];
        try {
            money(__assign({}, options, { value: amount, name: options.name + ":" + index, optional: false }));
        }
        catch (e) {
            dataErrors.push(e);
        }
        return dataErrors;
    }).filter(function (item) { return item.length; });
    if (errors.length) {
        error(options, errors);
        error(options, errors);
    }
};
exports.VALIDATORS = {
    string: string,
    number: number,
    required: required,
    numberLike: numberLike,
    money: money,
    aliasName: aliasName,
    address: address,
    boolean: boolean,
    assetId: assetId,
    timestamp: timestamp,
    orderType: orderType,
    assetName: assetName,
    assetDescription: assetDescription,
    httpsUrl: httpsUrl,
    attachment: attachment,
    transfers: transfers,
    aliasOrAddress: aliasOrAddress,
    data: data,
    script: script,
    asset_script: asset_script,
    binary: binary,
    precision: precision,
    call: call,
    payment: payment,
};
//# sourceMappingURL=fieldValidator.js.map