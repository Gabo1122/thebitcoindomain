"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var bignumber_1 = require("@waves/bignumber");
var ramda_1 = require("ramda");
var prepareTx_1 = require("./prepareTx");
function find(some, list) {
    var keys = Object.keys(some);
    var isEqual = function (a) { return keys.every(function (n) { return a[n] === some[n]; }); };
    for (var i = 0; i < list.length; i++) {
        if (isEqual(list[i])) {
            return list[i];
        }
    }
    return null;
}
exports.find = find;
function isEmpty(some) {
    return some == null;
}
exports.isEmpty = isEmpty;
function normalizeAssetId(assetId) {
    return assetId || prepareTx_1.WAVES_ID;
}
exports.normalizeAssetId = normalizeAssetId;
function last(list) {
    return list[list.length - 1];
}
exports.last = last;
exports.TRANSACTION_TYPE = {
    GENESIS: 1,
    PAYMENT: 2,
    ISSUE: 3,
    TRANSFER: 4,
    REISSUE: 5,
    BURN: 6,
    EXCHANGE: 7,
    LEASE: 8,
    CANCEL_LEASE: 9,
    ALIAS: 10,
    MASS_TRANSFER: 11,
    DATA: 12,
    SET_SCRIPT: 13,
    SPONSORSHIP: 14,
    SET_ASSET_SCRIPT: 15,
    SCRIPT_INVOCATION: 16
};
function currentCreateOrderFactory(config, minOrderFee) {
    return function (order, hasScript, smartAssetIdList) {
        if (hasScript === void 0) { hasScript = false; }
        if (smartAssetIdList === void 0) { smartAssetIdList = []; }
        var accountFee = hasScript ? new bignumber_1.BigNumber(config.smart_account_extra_fee) : new bignumber_1.BigNumber(0);
        var extraFee = Object
            .values(order.assetPair)
            .map(function (id) {
            return id && smartAssetIdList.includes(id) ? new bignumber_1.BigNumber(config.smart_asset_extra_fee) : new bignumber_1.BigNumber(0);
        })
            .reduce(function (sum, item) { return sum.add(item); }, new bignumber_1.BigNumber(0));
        return minOrderFee.add(accountFee).add(extraFee);
    };
}
exports.currentCreateOrderFactory = currentCreateOrderFactory;
function currentFeeFactory(config) {
    return function (tx, bytes, hasAccountScript, smartAssetIdList) {
        var accountFee = hasAccountScript ? new bignumber_1.BigNumber(config.smart_account_extra_fee) : new bignumber_1.BigNumber(0);
        var minFee = accountFee.add(getConfigProperty(tx.type, 'fee', config));
        switch (tx.type) {
            case exports.TRANSACTION_TYPE.CANCEL_LEASE:
            case exports.TRANSACTION_TYPE.ALIAS:
            case exports.TRANSACTION_TYPE.LEASE:
            case exports.TRANSACTION_TYPE.SET_ASSET_SCRIPT:
            case exports.TRANSACTION_TYPE.SET_SCRIPT:
            case exports.TRANSACTION_TYPE.SPONSORSHIP:
                return minFee;
            case exports.TRANSACTION_TYPE.REISSUE:
            case exports.TRANSACTION_TYPE.BURN:
            case exports.TRANSACTION_TYPE.TRANSFER:
                return minFee.add(getSmartAssetFeeByAssetId(tx.assetId, config, smartAssetIdList || []));
            case exports.TRANSACTION_TYPE.MASS_TRANSFER:
                return minFee.add(getMassTransferFee(tx, config, smartAssetIdList || []));
            case exports.TRANSACTION_TYPE.DATA:
                return accountFee.add(getDataFee(bytes, tx, config));
            case exports.TRANSACTION_TYPE.ISSUE:
                return getIssueFee(tx, accountFee, config);
            default:
                throw new Error('Wrong transaction type!');
        }
    };
}
exports.currentFeeFactory = currentFeeFactory;
function isNFT(tx) {
    var quantity = tx.quantity, precision = tx.precision, decimals = tx.decimals, reissuable = tx.reissuable;
    var nftQuantity = new bignumber_1.BigNumber(quantity).eq(1);
    var nftPrecision = new bignumber_1.BigNumber(precision || decimals || 0).eq(0);
    return !reissuable && nftPrecision && nftQuantity;
}
function getIssueFee(tx, accountFee, config) {
    var minFee = accountFee.add(getConfigProperty(tx.type, 'fee', config));
    if (isNFT(tx)) {
        return accountFee.add(getConfigProperty(tx.type, 'nftFee', config));
    }
    else {
        return minFee;
    }
}
function getSmartAssetFeeByAssetId(assetId, config, smartAssetIdList) {
    return assetId && smartAssetIdList.includes(assetId) ? new bignumber_1.BigNumber(config.smart_asset_extra_fee) : new bignumber_1.BigNumber(0);
}
function getDataFee(bytes, tx, config) {
    var kbPrice = getConfigProperty(tx.type, 'price_per_kb', config) || 0;
    return new bignumber_1.BigNumber(kbPrice).mul(Math.floor(1 + (bytes.length - 1) / 1024));
}
function getMassTransferFee(tx, config, smartAssetIdList) {
    var transferPrice = new bignumber_1.BigNumber(getConfigProperty(tx.type, 'price_per_transfer', config) || 0);
    var transfersCount = ramda_1.path(['transfers', 'length'], tx) || 0;
    var smartAssetExtraFee = tx.assetId && smartAssetIdList.includes(tx.assetId) ? new bignumber_1.BigNumber(config.smart_asset_extra_fee) : new bignumber_1.BigNumber(0);
    var minPriceStep = new bignumber_1.BigNumber(getConfigProperty(tx.type, 'min_price_step', config));
    var price = transferPrice.mul(transfersCount);
    if (!price.div(minPriceStep).isInt()) {
        price = price.div(minPriceStep).roundTo(0, 0).mul(minPriceStep);
    }
    return price.add(smartAssetExtraFee);
}
function getConfigProperty(type, propertyName, config) {
    var value = ramda_1.path(['calculate_fee_rules', type, propertyName], config);
    return isEmpty(value) ? ramda_1.path(['calculate_fee_rules', 'default', propertyName], config) : value;
}
//# sourceMappingURL=utils.js.map