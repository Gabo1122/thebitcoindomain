"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var Adapter_1 = require("./Adapter");
var ledger_1 = require("@waves/ledger");
var prepareTx_1 = require("../prepareTx");
var LedgerAdapter = (function (_super) {
    __extends(LedgerAdapter, _super);
    function LedgerAdapter(user) {
        var _this = _super.call(this) || this;
        _this._currentUser = user;
        if (!_this._currentUser) {
            throw 'No selected user';
        }
        return _this;
    }
    LedgerAdapter.prototype.isAvailable = function () {
        return this._isMyLedger();
    };
    LedgerAdapter.prototype.getPublicKey = function () {
        return Promise.resolve(this._currentUser.publicKey);
    };
    LedgerAdapter.prototype.getAddress = function () {
        return Promise.resolve(this._currentUser.address);
    };
    LedgerAdapter.prototype.getSeed = function () {
        return Promise.reject(Error('Method "getSeed" is not available!'));
    };
    LedgerAdapter.prototype.getAdapterVersion = function () {
        return LedgerAdapter._ledger.getVersion();
    };
    LedgerAdapter.prototype.signRequest = function (bytes) {
        var _this = this;
        return this._isMyLedger()
            .then(function () { return LedgerAdapter._ledger.signRequest(_this._currentUser.id, bytes); });
    };
    LedgerAdapter.prototype.signTransaction = function (bytes, amountPrecision) {
        var _this = this;
        if (bytes[0] === 15) {
            return this.signData(bytes);
        }
        return this._isMyLedger()
            .then(function () { return LedgerAdapter._ledger.signTransaction(_this._currentUser.id, { precision: amountPrecision }, bytes); });
    };
    LedgerAdapter.prototype.signOrder = function (bytes, amountPrecision) {
        var _this = this;
        return this._isMyLedger()
            .then(function () { return LedgerAdapter._ledger.signOrder(_this._currentUser.id, { precision: amountPrecision }, bytes); });
    };
    LedgerAdapter.prototype.signData = function (bytes) {
        var _this = this;
        return this._isMyLedger()
            .then(function () { return LedgerAdapter._ledger.signSomeData(_this._currentUser.id, bytes); });
    };
    LedgerAdapter.prototype.getPrivateKey = function () {
        return Promise.reject('No private key');
    };
    LedgerAdapter.prototype.getSignVersions = function () {
        var _a;
        return _a = {},
            _a[prepareTx_1.SIGN_TYPE.AUTH] = [1],
            _a[prepareTx_1.SIGN_TYPE.MATCHER_ORDERS] = [1],
            _a[prepareTx_1.SIGN_TYPE.CREATE_ORDER] = [1, 2, 3],
            _a[prepareTx_1.SIGN_TYPE.CANCEL_ORDER] = [1],
            _a[prepareTx_1.SIGN_TYPE.COINOMAT_CONFIRMATION] = [1],
            _a[prepareTx_1.SIGN_TYPE.ISSUE] = [2],
            _a[prepareTx_1.SIGN_TYPE.TRANSFER] = [2],
            _a[prepareTx_1.SIGN_TYPE.REISSUE] = [2],
            _a[prepareTx_1.SIGN_TYPE.BURN] = [2],
            _a[prepareTx_1.SIGN_TYPE.EXCHANGE] = [],
            _a[prepareTx_1.SIGN_TYPE.LEASE] = [2],
            _a[prepareTx_1.SIGN_TYPE.CANCEL_LEASING] = [2],
            _a[prepareTx_1.SIGN_TYPE.CREATE_ALIAS] = [2],
            _a[prepareTx_1.SIGN_TYPE.MASS_TRANSFER] = [1],
            _a[prepareTx_1.SIGN_TYPE.DATA] = [1],
            _a[prepareTx_1.SIGN_TYPE.SET_SCRIPT] = [1],
            _a[prepareTx_1.SIGN_TYPE.SPONSORSHIP] = [1],
            _a[prepareTx_1.SIGN_TYPE.SET_ASSET_SCRIPT] = [1],
            _a[prepareTx_1.SIGN_TYPE.SCRIPT_INVOCATION] = [1],
            _a;
    };
    LedgerAdapter.prototype._isMyLedger = function () {
        var _this = this;
        return LedgerAdapter._ledger.getUserDataById(this._currentUser.id)
            .then(function (user) {
            if (user.address !== _this._currentUser.address) {
                throw { error: 'Invalid ledger' };
            }
        });
    };
    LedgerAdapter.getUserList = function (from, to) {
        if (from === void 0) { from = 1; }
        if (to === void 0) { to = 1; }
        return LedgerAdapter._ledger.getPaginationUsersData(from, to);
    };
    LedgerAdapter.initOptions = function (options) {
        Adapter_1.Adapter.initOptions(options);
        this._ledger = new ledger_1.WavesLedger(options);
    };
    LedgerAdapter.isAvailable = function () {
        if (!LedgerAdapter._hasConnectionPromise) {
            LedgerAdapter._hasConnectionPromise = LedgerAdapter._ledger.probeDevice();
        }
        return LedgerAdapter._hasConnectionPromise.then(function () {
            LedgerAdapter._hasConnectionPromise = null;
            return true;
        }, function (err) {
            LedgerAdapter._hasConnectionPromise = null;
            return false;
        });
    };
    LedgerAdapter.type = "ledger";
    return LedgerAdapter;
}(Adapter_1.Adapter));
exports.LedgerAdapter = LedgerAdapter;
//# sourceMappingURL=LedgerAdapter.js.map