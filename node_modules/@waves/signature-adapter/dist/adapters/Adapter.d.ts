import { AdapterType } from '../config';
import { SIGN_TYPE, TSignData } from '../prepareTx';
import { Signable } from '../Signable';
export declare abstract class Adapter {
    type: string;
    protected _code: number;
    protected static _code: number;
    protected constructor(networkCode?: string | number);
    makeSignable(forSign: TSignData): Signable;
    isAvailable(): Promise<void>;
    onDestroy(cb?: Function): void;
    getNetworkByte(): number;
    abstract getSignVersions(): Record<SIGN_TYPE, Array<number>>;
    abstract getPublicKey(): Promise<string>;
    abstract getAddress(): Promise<string>;
    abstract getPrivateKey(): Promise<string>;
    abstract signRequest(databytes: Uint8Array, signData?: any): Promise<string>;
    abstract signTransaction(bytes: Uint8Array, amountPrecision: number, signData?: any): Promise<string>;
    abstract signOrder(bytes: Uint8Array, amountPrecision: number, signData: any): Promise<string>;
    abstract signData(bytes: Uint8Array): Promise<string>;
    abstract getSeed(): Promise<string>;
    static initOptions(options: {
        networkCode: number;
    }): void;
    static type: AdapterType;
    static getUserList(): Promise<Array<string>>;
    static isAvailable(): Promise<boolean>;
}
export interface IAdapterConstructor {
    new (): Adapter;
    type: AdapterType;
    getUserList(): Promise<Array<string>>;
    isAvailable(): Promise<boolean>;
}
export interface IUser {
    encryptedSeed: string;
    encryptedPrivateKey: string;
    password: string;
    encryptionRounds: number;
}
export interface IProofData {
    profs?: Array<string>;
    signature?: string;
}
